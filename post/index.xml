<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rubinera1n&#39;s Blog</title>
    <link>https://blog.xiufuguo.com/post/</link>
    <description>Recent content in Posts on Rubinera1n&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 05 Jul 2020 01:03:39 +0800</lastBuildDate>
    
	<atom:link href="https://blog.xiufuguo.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[LeetCode] 104. Maximum Depth of Binary Tree</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/maximum-depth-of-binary-tree/</link>
      <pubDate>Sun, 05 Jul 2020 01:03:39 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/maximum-depth-of-binary-tree/</guid>
      <description>104. Maximum Depth of Binary Tree
python
1 2 3 4 5  class Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 107. Binary Tree Level Order Traversal II</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/binary-tree-level-order-traversal-ii/</link>
      <pubDate>Sun, 05 Jul 2020 01:01:23 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/binary-tree-level-order-traversal-ii/</guid>
      <description>107. Binary Tree Level Order Traversal II
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  class Solution: &amp;#34;&amp;#34;&amp;#34; def levelOrderBottom(self, root: TreeNode) -&amp;gt; List[List[int]]: # BFS + Queue queue, res = collections.deque([(root, 0)]), [] while queue: node, level = queue.popleft() if node: if len(res) &amp;lt; level + 1: res.</description>
    </item>
    
    <item>
      <title>[LeetCode] 96. Unique Binary Search Trees</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/unique-binary-search-trees/</link>
      <pubDate>Sun, 05 Jul 2020 00:58:28 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/unique-binary-search-trees/</guid>
      <description>96. Unique Binary Search Trees
python
1 2 3 4 5 6 7 8  class Solution: def numTrees(self, n: int) -&amp;gt; int: res = [0] * (n + 1) res[0] = 1 for i in range(1, n + 1): for j in range(i): res[i] += res[j] * res[i-1-j] return res[n]   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 95. Unique Binary Search Trees II</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/unique-binary-search-trees-ii/</link>
      <pubDate>Sun, 05 Jul 2020 00:56:02 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/unique-binary-search-trees-ii/</guid>
      <description>95. Unique Binary Search Trees II
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def generateTrees(self, n: int) -&amp;gt; List[TreeNode]: def generate(l, r): # split between [l, r) if l == r: return [None] nodes = [] for i in range(l, r): for lchild in generate(l, i): for rchild in generate(i+1, r): node = TreeNode(i+1) # +1 to convert the index to the actual value node.</description>
    </item>
    
    <item>
      <title>[LeetCode] 102. Binary Tree Level Order Traversal</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/binary-tree-level-order-traversal/</link>
      <pubDate>Sun, 05 Jul 2020 00:52:52 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/binary-tree-level-order-traversal/</guid>
      <description>102. Binary Tree Level Order Traversal
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  class Solution: &amp;#34;&amp;#34;&amp;#34; # DFS def levelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]: res = [] self.dfs(root, 0, res) return res def dfs(self, root, level, res): if not root: return if len(res) &amp;lt;= level: res.</description>
    </item>
    
    <item>
      <title>[LeetCode] 94. Binary Tree Inorder Traversal</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/binary-tree-inorder-traversal/</link>
      <pubDate>Sun, 05 Jul 2020 00:50:40 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/binary-tree-inorder-traversal/</guid>
      <description>94. Binary Tree Inorder Traversal
python
1 2 3 4 5 6 7 8 9 10 11 12 13  class Solution: def inorderTraversal(self, root: TreeNode) -&amp;gt; List[int]: res = [] self.helper(root, res) return res def helper(self, root, res): if not root: return self.helper(root.left, res) res.append(root.val) self.helper(root.right, res)   go
1 2 3 4 5 6 7 8 9 10 11 12 13 14  func inorderTraversal(root *TreeNode) []int { res := []int{} dfs(root, &amp;amp;res) return res } func dfs(node *TreeNode, res *[]int) { if node == nil { return } dfs(node.</description>
    </item>
    
    <item>
      <title>[LeetCode] 101. Symmetric Tree</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/symmetric-tree/</link>
      <pubDate>Sun, 05 Jul 2020 00:47:21 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/symmetric-tree/</guid>
      <description>101. Symmetric Tree
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def isSymmetric(self, root: TreeNode) -&amp;gt; bool: if not root: return True return self.helper(root.left, root.right) def helper(self, left, right): if not left and not right: return True if not left or not right: return False if left.val != right.val: return False return self.helper(left.left, right.right) and self.helper(left.right, right.left)   go</description>
    </item>
    
    <item>
      <title>[LeetCode] 100. Same Tree</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/same-tree/</link>
      <pubDate>Sun, 05 Jul 2020 00:32:28 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/same-tree/</guid>
      <description>100. Same Tree
python
1 2 3 4 5 6 7 8  class Solution: def isSameTree(self, p: TreeNode, q: TreeNode) -&amp;gt; bool: if not p and not q: return True if not p or not q: return False return p.val == q.val and self.isSameTree(p.left, q.left) and \ self.isSameTree(p.right, q.right)   go
1 2 3 4 5 6 7 8 9  func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil &amp;amp;&amp;amp; q == nil { return true } if p == nil || q == nil { return false } return p.</description>
    </item>
    
    <item>
      <title>MOOC</title>
      <link>https://blog.xiufuguo.com/post/life/mooc/</link>
      <pubDate>Sun, 31 May 2020 15:36:12 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/life/mooc/</guid>
      <description>最近发现 Coursera 六月课程要开始了，以前念书时就知道 MOOC，工作求职开始用 Linkedin，突然发现证书可以发布到 Linkedin，这样可以增加面</description>
    </item>
    
    <item>
      <title>Set Goal</title>
      <link>https://blog.xiufuguo.com/post/life/set_goal/</link>
      <pubDate>Mon, 25 May 2020 06:40:00 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/life/set_goal/</guid>
      <description>2020年上半年快结束了，突然想写 Blog 记录下自己的生活与技术学习， 自己习惯用Scrivener做笔记，真的没有习惯写博客，写一些生活记录比较容</description>
    </item>
    
    <item>
      <title>Reverse Linked List</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/reverse_linked_list/</link>
      <pubDate>Tue, 19 May 2020 01:53:36 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/reverse_linked_list/</guid>
      <description>code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35  class ListNode: def __init__(self, x): self.value = x self.next = None def reverse_link(head): if not head: return pre, nxt, curr = None, None, head while curr: nxt = curr.next curr.next = pre pre = curr curr = nxt return pre def create_link(nums): dummy = ListNode(0) curr = dummy for i in nums: curr.</description>
    </item>
    
    <item>
      <title>HashMap</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/hash_table/</link>
      <pubDate>Tue, 19 May 2020 01:48:20 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/hash_table/</guid>
      <description>code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  class ListNode: def __init__(self, key, value): self.</description>
    </item>
    
    <item>
      <title>Tree Traversal</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/tree_traversal/</link>
      <pubDate>Tue, 19 May 2020 01:20:06 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/tree_traversal/</guid>
      <description>preorder inorder postorder  code
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51  class TreeNode(object): def __init__(self, x): self.val = x self.left = None self.right = None def make_tree(lst): node = None if not lst: return if lst[0] is not None: node = TreeNode(lst.</description>
    </item>
    
    <item>
      <title>DFS</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/dfs/</link>
      <pubDate>Mon, 18 May 2020 22:41:51 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/dfs/</guid>
      <description>Check whether there is a path from |start| to |target| in graph G.
neighbor(x) returns the neighbors of x in G.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  seen = set([start]) def dfs(n): if n == target: return True for t in neighbor(n): if t in seen: continue seen.add(t) if dfs(t): return True seen.remove(t) # back-tracking return False return dfs(start)   </description>
    </item>
    
    <item>
      <title>BFS</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/bfs/</link>
      <pubDate>Mon, 18 May 2020 22:39:32 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/bfs/</guid>
      <description>Find the shortest path from |start| to |target| in a unweighted graph G.
neighbor(x) returns the neighbors of x in G.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  q = deque([start]) seen = set([start]) steps = 0 while q: size = len(q) for _ in range(size): n = q.popleft() if n == target: return steps for t in neighbor(n): if t in seen: continue q.</description>
    </item>
    
    <item>
      <title>Sliding Window</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/sliding_window/</link>
      <pubDate>Mon, 18 May 2020 21:59:16 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/sliding_window/</guid>
      <description>面试常见题型。无意间发现国内版力扣，有人归类滑动窗口，写的不错。链结 题目参考：LeetCode 3. Combinations 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Given a string, find the</description>
    </item>
    
    <item>
      <title>Combinations</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/combinations/</link>
      <pubDate>Mon, 18 May 2020 21:51:50 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/combinations/</guid>
      <description>思路：使用一个常量记录位置，避免重复 1 2 3 4 5 6 7 8 9 10 11 def C(n, m, idx, cur): if len(cur) == m: print(cur) return for i in range(idx, n): cur.append(i + 1) C(n, m, i + 1, cur) cur.pop() n, m = 5, 3 C(n, m, 0, []) 参考题目： LeetCode</description>
    </item>
    
    <item>
      <title>Permutations</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/permutations/</link>
      <pubDate>Mon, 18 May 2020 21:40:49 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/permutations/</guid>
      <description>思路：使用数组记住使用过数字 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 def P(n, m, cur, used): if len(cur) == m: print(cur) return for i in range(n): if used[i]: continue used[i] = True cur.append(i + 1) P(n, m, cur, used) cur.pop() used[i] = False n, m = 5, 3 P(n, m, [], [False]</description>
    </item>
    
    <item>
      <title>Binary Search</title>
      <link>https://blog.xiufuguo.com/post/leetcode/template/binary_search/</link>
      <pubDate>Mon, 18 May 2020 21:37:10 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/template/binary_search/</guid>
      <description>思路：左闭右开 [l, r) ，根据题目去判断，有很多变化题型 1 2 3 4 5 6 7 8 9 10 11 12 def binary_search(nums, target): l, r = 0, len(nums) while l &amp;lt; r: m = l + (r - l) // 2 # python不会溢出，</description>
    </item>
    
  </channel>
</rss>