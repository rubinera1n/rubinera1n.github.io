<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Rubinera1n&#39;s Blog</title>
    <link>https://blog.xiufuguo.com/post/</link>
    <description>Recent content in Posts on Rubinera1n&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 13 Jul 2020 22:49:12 +0800</lastBuildDate>
    
	<atom:link href="https://blog.xiufuguo.com/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[LeetCode] 448. Find All Numbers Disappeared in an Array</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/find-all-numbers-disappeared-in-an-array/</link>
      <pubDate>Mon, 13 Jul 2020 22:49:12 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/find-all-numbers-disappeared-in-an-array/</guid>
      <description>448. Find All Numbers Disappeared in an Array
python
1 2 3 4 5  class Solution: def findDisappearedNumbers(self, nums: List[int]) -&amp;gt; List[int]: a = set([i for i in range(1, len(nums) + 1)]) b = set(nums) return list(a - b)   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 442. Find All Duplicates in an Array</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/find-all-duplicates-in-an-array/</link>
      <pubDate>Mon, 13 Jul 2020 22:47:33 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/find-all-duplicates-in-an-array/</guid>
      <description>442. Find All Duplicates in an Array
python
1 2 3  class Solution: def findDuplicates(self, nums: List[int]) -&amp;gt; List[int]: return [key for key, value in collections.Counter(nums).items() if value == 2]   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 34. Find First and Last Position of Element in Sorted Array</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/find-first-and-last-position-of-element-in-sorted-array/</link>
      <pubDate>Sun, 12 Jul 2020 22:53:05 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/find-first-and-last-position-of-element-in-sorted-array/</guid>
      <description>34. Find First and Last Position of Element in Sorted Array
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  class Solution: def searchRange(self, nums: List[int], target: int) -&amp;gt; List[int]: if not nums: return [-1, -1] l, r = 0, len(nums) while l &amp;lt; r: mid = l + (r - l) // 2 if nums[mid] &amp;gt;= target: r = mid else: l = mid + 1 # tmp  start = l l, r = 0, len(nums) while l &amp;lt; r: mid = l + (r - l) // 2 if nums[mid] &amp;gt; target: r = mid else: l = mid + 1 end = l return [-1, -1] if start == end else [start, end - 1]   go</description>
    </item>
    
    <item>
      <title>[LeetCode] 33. Search in Rotated Sorted Array</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/search-in-rotated-sorted-array/</link>
      <pubDate>Sun, 12 Jul 2020 22:33:12 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/search-in-rotated-sorted-array/</guid>
      <description>33. Search in Rotated Sorted Array
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def search(self, nums: List[int], target: int) -&amp;gt; int: l, r = 0, len(nums) - 1 while l &amp;lt;= r: mid = l + (r - l) // 2 if nums[mid] == target: return mid elif nums[l] &amp;lt;= nums[mid]: if nums[l] &amp;lt;= target &amp;lt; nums[mid]: r = mid - 1 else: l = mid + 1 elif nums[mid] &amp;lt;= nums[r]: if nums[mid] &amp;lt; target &amp;lt;= nums[r]: l = mid + 1 else: r = mid - 1 return -1   go</description>
    </item>
    
    <item>
      <title>[LeetCode] 40. Combination Sum II</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/combination-sum-ii/</link>
      <pubDate>Sat, 11 Jul 2020 22:14:56 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/combination-sum-ii/</guid>
      <description>40. Combination Sum II
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def combinationSum2(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, lst, target, index, path, res): if target &amp;lt; 0: return if target == 0: res.append(path) return res for i in range(index, len(lst)): if i &amp;gt; index and lst[i] == lst[i-1]: continue self.</description>
    </item>
    
    <item>
      <title>[LeetCode] 39. Combination Sum</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/combination-sum/</link>
      <pubDate>Sat, 11 Jul 2020 22:13:05 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/combination-sum/</guid>
      <description>39. Combination Sum
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  class Solution: def combinationSum(self, candidates: List[int], target: int) -&amp;gt; List[List[int]]: res = [] candidates.sort() self.dfs(candidates, target, 0, [], res) return res def dfs(self, nums, target, idx, path, res): if target &amp;lt; 0: return if target == 0: res.append(path) return for i in range(idx, len(nums)): self.dfs(nums, target - nums[i], i, path + [nums[i]], res)   go</description>
    </item>
    
    <item>
      <title>[LeetCode] 118. Pascal&#39;s Triangle</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/pascals-triangle/</link>
      <pubDate>Fri, 10 Jul 2020 22:09:11 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/pascals-triangle/</guid>
      <description>118. Pascal&amp;rsquo;s Triangle
python
1 2 3 4 5 6 7 8 9 10 11  class Solution: def generate(self, numRows: int) -&amp;gt; List[List[int]]: res = [] for i in range(numRows): res.append([]) for j in range(i + 1): if j in (0, i): res[i].append(1) else: res[i].append(res[i-1][j-1] + res[i-1][j]) return res   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 66. Plus One</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/plus-one/</link>
      <pubDate>Fri, 10 Jul 2020 22:06:44 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/plus-one/</guid>
      <description>66. Plus One
python
1 2 3  class Solution: def plusOne(self, digits: List[int]) -&amp;gt; List[int]: return [int(a) for a in (str(int(&amp;#39;&amp;#39;.join(map(str, digits))) + 1))]   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 59. Spiral Matrix II</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/spiral-matrix-ii/</link>
      <pubDate>Thu, 09 Jul 2020 21:58:53 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/spiral-matrix-ii/</guid>
      <description>59. Spiral Matrix II
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  class Solution: def generateMatrix(self, n): if not n: return [] res = [[0 for _ in range(n)] for _ in range(n)] left, right, top, down, num = 0, n-1, 0, n-1, 1 while left &amp;lt;= right and top &amp;lt;= down: for i in range(left, right+1): res[top][i] = num num += 1 top += 1 for i in range(top, down+1): res[i][right] = num num += 1 right -= 1 for i in range(right, left-1, -1): res[down][i] = num num += 1 down -= 1 for i in range(down, top-1, -1): res[i][left] = num num += 1 left += 1 return res   go</description>
    </item>
    
    <item>
      <title>[LeetCode] 31. Next Permutation</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/next-permutation/</link>
      <pubDate>Thu, 09 Jul 2020 21:46:31 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/next-permutation/</guid>
      <description>31. Next Permutation
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  class Solution: def nextPermutation(self, nums: List[int]) -&amp;gt; None: i = len(nums) - 2 while i &amp;gt;= 0 and nums[i] &amp;gt;= nums[i+1]: i -= 1 if i &amp;lt; 0: # 6 5 4 3 2 1 nums.reverse() return j = len(nums) - 1 while j &amp;gt;= 0 and nums[i] &amp;gt;= nums[j]: j -= 1 nums[i], nums[j] = nums[j], nums[i] l, r = i + 1, len(nums) - 1 while l &amp;lt; r: nums[l], nums[r] = nums[r], nums[l] l += 1 r -= 1   go</description>
    </item>
    
    <item>
      <title>[LeetCode] 54. Spiral Matrix</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/spiral-matrix/</link>
      <pubDate>Wed, 08 Jul 2020 21:43:30 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/spiral-matrix/</guid>
      <description>54. Spiral Matrix python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class Solution: def spiralOrder(self, matrix: List[List[int]]) -&amp;gt; List[int]: if not matrix: return [] res = [] left, right = 0, len(matrix[0]) - 1 top, bottom = 0, len(matrix) - 1 while</description>
    </item>
    
    <item>
      <title>[LeetCode] 48. Rotate Image</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/array/rotate-image/</link>
      <pubDate>Wed, 08 Jul 2020 21:09:12 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/array/rotate-image/</guid>
      <description>48. Rotate Image
python
1 2 3 4 5 6  class Solution: def rotate(self, matrix: List[List[int]]) -&amp;gt; None: &amp;#34;&amp;#34;&amp;#34; Do not return anything, modify matrix in-place instead. &amp;#34;&amp;#34;&amp;#34; matrix[:] = zip(*matrix[::-1])   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 110. Balanced Binary Tree</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/balanced-binary-tree/</link>
      <pubDate>Tue, 07 Jul 2020 14:37:34 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/balanced-binary-tree/</guid>
      <description>110. Balanced Binary Tree
python
1 2 3 4 5 6 7 8 9 10  class Solution: def isBalanced(self, root: TreeNode) -&amp;gt; bool: return self.helper(root)[1] def helper(self, root): if not root: return (0, True) l_depth, l_balanced = self.helper(root.left) r_depth, r_balanced = self.helper(root.right) return max(l_depth, r_depth) + 1, l_balanced and r_balanced and abs(l_depth - r_depth) &amp;lt;= 1   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 98. Validate Binary Search Tree</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/validate-binary-search-tree/</link>
      <pubDate>Tue, 07 Jul 2020 14:31:46 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/validate-binary-search-tree/</guid>
      <description>98. Validate Binary Search Tree
python
1 2 3 4 5 6 7 8 9 10  class Solution: def isValidBST(self, root: TreeNode) -&amp;gt; bool: return self.helper(root, float(&amp;#39;-inf&amp;#39;), float(&amp;#39;inf&amp;#39;)) def helper(self, root, lower, upper): if not root: return True return root.val &amp;gt; lower and root.val &amp;lt; upper \ and self.helper(root.left, lower, root.val) \ and self.helper(root.right, root.val, upper)   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 108. Convert Sorted Array to Binary Search Tree</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/convert-sorted-array-to-binary-search-tree/</link>
      <pubDate>Mon, 06 Jul 2020 11:58:22 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/convert-sorted-array-to-binary-search-tree/</guid>
      <description>108. Convert Sorted Array to Binary Search Tree
python
1 2 3 4 5 6 7 8 9 10  class Solution: def sortedArrayToBST(self, nums: List[int]) -&amp;gt; TreeNode: l, r = 0, len(nums) - 1 if l &amp;lt;= r: m = l + (r - l) // 2 root = TreeNode(nums[m]) root.left = self.sortedArrayToBST(nums[:m]) root.right = self.sortedArrayToBST(nums[m+1:]) return root   go
   </description>
    </item>
    
    <item>
      <title>[LeetCode] 103. Binary Tree Zigzag Level Order Traversal</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Mon, 06 Jul 2020 11:50:03 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/binary-tree-zigzag-level-order-traversal/</guid>
      <description>103. Binary Tree Zigzag Level Order Traversal
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  class Solution: def zigzagLevelOrder(self, root: TreeNode) -&amp;gt; List[List[int]]: res = [] self.dfs(root, 0, res) return res def dfs(self, root, level, res): if not root: return if len(res) &amp;lt;= level: res.</description>
    </item>
    
    <item>
      <title>Head First Goroutine</title>
      <link>https://blog.xiufuguo.com/post/golang/head_first_goroutine/</link>
      <pubDate>Mon, 06 Jul 2020 04:07:47 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/golang/head_first_goroutine/</guid>
      <description>深入浅出 Go 协程 一、什么是 Goroutines Goroutines 是用户空间线程。 从概念上讲，它类似于由 OS 管理的内核线程，但完全由 Go 运行时管理。 比内核线程更轻巧，更便宜。 调度程序</description>
    </item>
    
    <item>
      <title>[LeetCode] 106. Construct Binary Tree from Inorder and Postorder Traversal</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/construct-binary-tree-from-inorder-and-postorder-traversal/</link>
      <pubDate>Sun, 05 Jul 2020 15:18:39 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/construct-binary-tree-from-inorder-and-postorder-traversal/</guid>
      <description>106. Construct Binary Tree from Inorder and Postorder Traversal
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def buildTree(self, inorder: List[int], postorder: List[int]) -&amp;gt; TreeNode: if not inorder or not postorder: return None return self.helper(inorder, 0, len(inorder) - 1, postorder, 0, len(postorder) - 1) def helper(self, inorder, i_left, i_right, postorder, p_left, p_right): if i_left &amp;gt; i_right: return None if i_left == i_right: return TreeNode(postorder[p_right]) idx = inorder.</description>
    </item>
    
    <item>
      <title>[LeetCode] 105. Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Sun, 05 Jul 2020 15:16:20 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>105. Construct Binary Tree from Preorder and Inorder Traversal
python
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  class Solution: def buildTree(self, preorder: List[int], inorder: List[int]) -&amp;gt; TreeNode: if not preorder or not inorder: return None return self.helper(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1) def helper(self, preorder, p_left, p_right, inorder, i_left, i_right): if p_left &amp;gt; p_right: return None if p_left == p_right: return TreeNode(preorder[p_left]) idx = inorder.</description>
    </item>
    
    <item>
      <title>[LeetCode] 104. Maximum Depth of Binary Tree</title>
      <link>https://blog.xiufuguo.com/post/leetcode/tags/tree/maximum-depth-of-binary-tree/</link>
      <pubDate>Sat, 04 Jul 2020 01:03:39 +0800</pubDate>
      
      <guid>https://blog.xiufuguo.com/post/leetcode/tags/tree/maximum-depth-of-binary-tree/</guid>
      <description>104. Maximum Depth of Binary Tree
python
1 2 3 4 5  class Solution: def maxDepth(self, root: TreeNode) -&amp;gt; int: if not root: return 0 return max(self.maxDepth(root.left), self.maxDepth(root.right)) + 1   go
   </description>
    </item>
    
  </channel>
</rss>