<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>深入浅出 Go 协程 - Rubinera1n&#39;s Blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="rubinera1n" />
  <meta name="description" content="深入浅出 Go 协程 一、什么是 Goroutines Goroutines 是用户空间线程。 从概念上讲，它类似于由 OS 管理的内核线程，但完全由 Go 运行时管理。 比内核线程更轻巧，更便宜。 调度程序" />

  <meta name="keywords" content="Hugo, blog, rubinera1n" />






<meta name="generator" content="Hugo 0.72.0" />


<link rel="canonical" href="https://blog.xiufuguo.com/post/golang/head_first_goroutine/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa3d941d1d0e0ddc985804227feabffea55c89883eb0af34e0532a7ae9135151.css" integrity="sha256-&#43;j2UHR0ODdyYWAQif&#43;q//qVciYg&#43;sK804FMqeukTUVE=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="深入浅出 Go 协程" />
<meta property="og:description" content="深入浅出 Go 协程 一、什么是 Goroutines Goroutines 是用户空间线程。 从概念上讲，它类似于由 OS 管理的内核线程，但完全由 Go 运行时管理。 比内核线程更轻巧，更便宜。 调度程序" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.xiufuguo.com/post/golang/head_first_goroutine/" />
<meta property="article:published_time" content="2020-07-06T04:07:47+08:00" />
<meta property="article:modified_time" content="2020-07-06T11:03:56+08:00" />
<meta itemprop="name" content="深入浅出 Go 协程">
<meta itemprop="description" content="深入浅出 Go 协程 一、什么是 Goroutines Goroutines 是用户空间线程。 从概念上讲，它类似于由 OS 管理的内核线程，但完全由 Go 运行时管理。 比内核线程更轻巧，更便宜。 调度程序">
<meta itemprop="datePublished" content="2020-07-06T04:07:47&#43;08:00" />
<meta itemprop="dateModified" content="2020-07-06T11:03:56&#43;08:00" />
<meta itemprop="wordCount" content="8380">



<meta itemprop="keywords" content="golang," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入浅出 Go 协程"/>
<meta name="twitter:description" content="深入浅出 Go 协程 一、什么是 Goroutines Goroutines 是用户空间线程。 从概念上讲，它类似于由 OS 管理的内核线程，但完全由 Go 运行时管理。 比内核线程更轻巧，更便宜。 调度程序"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">rubinera1n</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      rubinera1n
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">深入浅出 Go 协程</h1>
      
      <div class="post-meta">
        <time datetime="2020-07-06" class="post-time">
          2020-07-06
        </time>
        <div class="post-category">
            <a href="https://blog.xiufuguo.com/categories/golang/"> golang </a>
            
          </div>
        <span class="more-meta"> 8380 words </span>
          <span class="more-meta"> 17 min read </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#一什么是-goroutines">一、什么是 Goroutines</a></li>
    <li><a href="#二scheduler-底层原理">二、scheduler 底层原理</a>
      <ul>
        <li><a href="#go-scheduler">Go Scheduler</a></li>
        <li><a href="#线程模型">线程模型</a></li>
        <li><a href="#g---m---p-模型">G - M - P 模型</a></li>
      </ul>
    </li>
    <li><a href="#三goroutines-是怎么工作的-">三、Goroutines 是怎么工作的 ？</a>
      <ul>
        <li><a href="#go-程序启动过程">Go 程序启动过程</a></li>
        <li><a href="#goroutine-的运行过程">goroutine 的运行过程</a></li>
        <li><a href="#抢占式调度">抢占式调度</a></li>
        <li><a href="#总结">总结</a></li>
      </ul>
    </li>
    <li><a href="#四参考资料">四、参考资料</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h1 id="深入浅出-go-协程">深入浅出 Go 协程</h1>
<h2 id="一什么是-goroutines">一、什么是 Goroutines</h2>
<p>Goroutines 是用户空间线程。</p>
<ul>
<li>
<p>从概念上讲，它类似于由 OS 管理的内核线程，但<strong>完全由 Go 运行时管理</strong>。</p>
</li>
<li>
<p><strong>比内核线程更轻巧，更便宜</strong>。</p>
<ul>
<li>
<p>调度程序将其复用到内核线程上：</p>
<p>初始 goroutine堆栈 = 2KB；默认线程堆栈 = 8KB，状态跟踪开销。</p>
</li>
<li>
<p>更快的创建，销毁，上下文切换：</p>
<p>goroutine 开关=〜ns，线程开关=〜aμs。</p>
</li>
</ul>
</li>
</ul>
<p><strong>Goroutine 可以看作对 thread 加一层抽象</strong>，它更轻量级，可以单独执行。因为有了这层抽象，Gopher 不会直接面对 thread。对于操作系统不管你抽象什么，线程才是我调度的基本单位。</p>
<p><img src="https://heuristic-nightingale-6c42ab.netlify.app/img/go_scheduler_1.png" alt="png"></p>
<h2 id="二scheduler-底层原理">二、scheduler 底层原理</h2>
<h3 id="go-scheduler">Go Scheduler</h3>
<hr>
<p>在了解 Go 运行时的 scheduler 之前，需要先了解为什么需要它，因为我们可能会想，OS 内核不是已经有一个线程 scheduler 了嘛？</p>
<p>熟悉 POSIX thread API 的人都知道，POSIX 在很大程度上对现有 Unix 进程模型逻辑进行扩展，因此，线程获得了许多与进程相同的控件。线程具有自己的信号掩码，可以分配给 <a href="https://en.wikipedia.org/wiki/Processor_affinity">CPU affinity</a>，可以放入 <a href="https://en.wikipedia.org/wiki/Cgroups">cgroups</a> 中，并可以查询它们使用的资源。但是很多特征对于 Go 程序来说都是累赘。 尤其是 context 上下文切换的耗时。</p>
<p>另一个原因是 Go 的垃圾回收需要所有的 goroutine 停止，内存必须处于一致状态。垃圾回收的时间点是不确定的，如果依靠 OS 自身的 scheduler 来调度，那么会有大量的线程需要停止工作。</p>
<p>单独的开发一个 Go 调度器，可以知道在什么时候内存状态是一致的，也就是说，当开始垃圾回收时，运行时只需要为当前正在 CPU 核上运行的那个线程等待即可，而不是等待所有的线程。</p>
<p>为此，Go 采用了类 coroutine 的概念来解决这些问题，Go 将之称为<code>goroutine</code>。</p>
<p>goroutine 占用的资源非常小，goroutine 调度的切换也不用陷入操作系统内核层完成，代价很低。因此，一个 Go 程序中可以创建成千上万个并发的 goroutine。所有的 Go 代码都在 goroutine 中执行，哪怕是 go 的 runtime 也不例外。将这些 goroutines 按照一定算法放到 CPU 上执行的程序就称为 <strong>go scheduler</strong>。</p>
<h3 id="线程模型">线程模型</h3>
<hr>
<p>线程的三种实现方式：用户级线程，内核级线程和混合型线程</p>
<ul>
<li>
<p>用户级线程，多对一（N : 1）：多个用户线程的一般从属于单个进程并且多线程的调度是由用户自己的线程库来完成，线程的创建、销毁以及多线程之间的协调等操作都是由用户自己的线程库来负责而无须借助系统调用来实现。一个进程中所有创建的线程都只和同一个 KSE 在运行时动态绑定，也就是说，操作系统只知道用户进程而对其中的线程是无感知的，内核的所有调度都是基于用户进程。许多语言实现的<strong>协程库</strong>基本上都属于这种方式（比如 python 的 gevent）。由于线程调度是在用户层面完成的，也就是相较于内核调度不需要让 CPU 在用户态和内核态之间切换，这种实现方式相比内核级线程可以做的很轻量级，对系统资源的消耗会小很多，因此可以创建的线程数量与上下文切换所花费的代价也会小得多。但该模型有个缺点：并不能做到真正意义上的并发。</p>
</li>
<li>
<p>内核级线程，一对一（1 : 1）：每一个用户线程绑定一个实际的内核线程，而线程的调度则完全交付给操作系统内核去做，应用程序对线程的创建、终止以及同步都基于内核提供的系统调用来完成，大部分编程语言的线程库（Java 的 java.lang.Thread、C++11 的 std::thread 等等）都是对操作系统的线程（内核级线程）的一层封装，创建出来的每个线程与一个独立的 KSE 静态绑定，因此其调度完全由操作系统内核调度器去做，也就是说，一个进程里创建出来的多个线程每一个都绑定一个 KSE。这种模型的优势和劣势同样明显：优势是实现简单，直接借助操作系统内核的线程以及调度器，所以 CPU 可以快速切换调度线程，于是多个线程可以同时运行，因此相较于用户级线程模型它真正做到了并行处理；但它的劣势是，由于直接借助了操作系统内核来创建、销毁和以及多个线程之间的上下文切换和调度，因此资源成本大幅上涨，且对性能影响很大。</p>
</li>
<li>
<p>混合型线程，多对多（M : N）：首先，区别于用户级线程模型，混合线程模型中的一个进程可以与多个内核线程 KSE 关联，也就是说一个进程内的多个线程可以分别绑定一个自己的 KSE，这点和内核级线程模型相似；其次，又区别于内核级线程模型，它的进程里的线程并不与 KSE 唯一绑定，而是可以多个用户线程映射到同一个 KSE，当某个 KSE 因为其绑定的线程的阻塞操作被内核调度出 CPU 时，其关联的进程中其余用户线程可以重新与其他 KSE 绑定运行。因为这种模型的高度复杂性，操作系统内核开发者一般不会使用，所以更多时候是作为第三方库的形式出现，而 <strong>Go 语言中的 runtime 调度器就是采用的这种实现方案</strong>，实现了 Goroutine 与 KSE 之间的动态关联。</p>
</li>
</ul>
<p>Go runtime 负责 goroutine 生命周期，从创建到销毁。runtime 会在程序启动的时候，创建 M 个线程，之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。这就是 M : N 模型：</p>
<p><img src="https://heuristic-nightingale-6c42ab.netlify.app/img/m_n_map_thread.png" alt="png"></p>
<h3 id="g---m---p-模型">G - M - P 模型</h3>
<hr>
<p>要理解协程的实现，首先需要了解 go 中的三个非常重要的概念, 它们分别是 <strong>G</strong>, <strong>M</strong> 和 <strong>P</strong>，这三项是协程最主要的组成部分。</p>
<p>相关代码目录：</p>
<ul>
<li>$GOROOT/src/runtime/asm_amd64.s</li>
<li>$GOROOT/src/runtime/proc.go</li>
<li>$GOROOT/src/runtime/runtime2.go</li>
</ul>
<p><strong>G</strong> 代表一个 goroutine 对象，每次 go 调用的时候，都会创建一个 G 对象，它包括栈、指令指针以及对于调用 goroutines 很重要的其它信息，比如阻塞它的任何 channel，其主要数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">stack</span>       <span class="nx">stack</span> <span class="c1">// 真实的栈内存，包括上下界
</span><span class="c1"></span>
	<span class="nx">m</span>            <span class="o">*</span><span class="nx">m</span>    <span class="c1">// 当前的m
</span><span class="c1"></span>	<span class="nx">sched</span>        <span class="nx">gobuf</span> <span class="c1">// goroutine切换时，用于保存g的上下文
</span><span class="c1"></span>	<span class="nx">param</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 用于传递参数，睡眠时其他goroutine可以设置param，唤醒时该goroutine可以获取
</span><span class="c1"></span>	<span class="cm">/*
</span><span class="cm">	Gidle 被创建但没初始换
</span><span class="cm">	Grunnable 可运行
</span><span class="cm">	Grunning 正在运行
</span><span class="cm">	Gsyscall 正在系统调用
</span><span class="cm">	Gwaiting 正在等待
</span><span class="cm">	Gdead 运行完成
</span><span class="cm">	*/</span>
	<span class="nx">atomicstatus</span> <span class="kt">uint32</span>   <span class="c1">// g的状态Gidle,Grunnable,Grunning,Gsyscall,Gwaiting,Gdead
</span><span class="c1"></span>	<span class="nx">goid</span>         <span class="kt">int64</span>    <span class="c1">// goroutine的ID
</span><span class="c1"></span>	<span class="nx">schedlink</span>    <span class="nx">guintptr</span> <span class="c1">// 下一个g, g链表
</span><span class="c1"></span>	<span class="nx">waitsince</span>    <span class="kt">int64</span>    <span class="c1">// g被阻塞的大体时间
</span><span class="c1"></span>
	<span class="nx">preempt</span>      <span class="kt">bool</span> <span class="c1">// 抢占标记
</span><span class="c1"></span>
	<span class="nx">lockedm</span>      <span class="nx">muintptr</span> <span class="c1">// g被锁定只在这个m上运行
</span><span class="c1"></span>	<span class="nx">gopc</span>         <span class="kt">uintptr</span>  <span class="c1">// 创建该goroutine的指令地址
</span><span class="c1"></span>	<span class="nx">startpc</span>      <span class="kt">uintptr</span>  <span class="c1">// goroutine函数的指令地址
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中最主要的当然是 sched 了，保存了 goroutine 的上下文。goroutine 切换的时候不同于线程有 OS 来负责这部分数据，而是由一个 gobuf 对象来保存，这样能够更加轻量级，再来看看 gobuf 的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">sp</span>   <span class="kt">uintptr</span>
    <span class="nx">pc</span>   <span class="kt">uintptr</span>
    <span class="nx">g</span>    <span class="nx">guintptr</span>
    <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span>
    <span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span>
    <span class="nx">lr</span>   <span class="kt">uintptr</span>
    <span class="nx">bp</span>   <span class="kt">uintptr</span> <span class="c1">// for GOEXPERIMENT=framepointer
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其实就是保存了当前的栈指针，计数器，当然还有 g 自身，这里记录自身 g 的指针是为了能快速的访问到 goroutine 中的信息。</p>
<p><strong>M</strong> 代表一个线程，每次创建一个 M 的时候，都会有一个底层线程创建；所有的 G 任务，最终还是在 M 上执行，其主要数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">g0</span>            <span class="o">*</span><span class="nx">g</span>     <span class="c1">// 带有调度栈的goroutine
</span><span class="c1"></span>
    <span class="nx">gsignal</span>       <span class="o">*</span><span class="nx">g</span>         <span class="c1">// 处理信号的goroutine
</span><span class="c1"></span>    <span class="nx">tls</span>           <span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// thread-local storage
</span><span class="c1"></span>    <span class="nx">mstartfn</span>      <span class="kd">func</span><span class="p">()</span>
    <span class="nx">curg</span>          <span class="o">*</span><span class="nx">g</span>       <span class="c1">// 当前运行的goroutine
</span><span class="c1"></span>    <span class="nx">caughtsig</span>     <span class="nx">guintptr</span>
    <span class="nx">p</span>             <span class="nx">puintptr</span> <span class="c1">// 关联p和执行的go代码
</span><span class="c1"></span>    <span class="nx">nextp</span>         <span class="nx">puintptr</span>
    <span class="nx">id</span>            <span class="kt">int32</span>
    <span class="nx">mallocing</span>     <span class="kt">int32</span> <span class="c1">// 状态
</span><span class="c1"></span>
    <span class="nx">spinning</span>      <span class="kt">bool</span> <span class="c1">// m是否out of work
</span><span class="c1"></span>    <span class="nx">blocked</span>       <span class="kt">bool</span> <span class="c1">// m是否被阻塞
</span><span class="c1"></span>    <span class="nx">inwb</span>          <span class="kt">bool</span> <span class="c1">// m是否在执行写屏蔽
</span><span class="c1"></span>
    <span class="nx">printlock</span>     <span class="kt">int8</span>
    <span class="nx">incgo</span>         <span class="kt">bool</span> <span class="c1">// m在执行cgo吗
</span><span class="c1"></span>    <span class="nx">fastrand</span>      <span class="kt">uint32</span>
    <span class="nx">ncgocall</span>      <span class="kt">uint64</span>      <span class="c1">// cgo调用的总数
</span><span class="c1"></span>    <span class="nx">ncgo</span>          <span class="kt">int32</span>       <span class="c1">// 当前cgo调用的数目
</span><span class="c1"></span>    <span class="nx">park</span>          <span class="nx">note</span>
    <span class="nx">alllink</span>       <span class="o">*</span><span class="nx">m</span> <span class="c1">// 用于链接allm
</span><span class="c1"></span>    <span class="nx">schedlink</span>     <span class="nx">muintptr</span> <span class="c1">// 下一个m, m链表
</span><span class="c1"></span>    <span class="nx">mcache</span>        <span class="o">*</span><span class="nx">mcache</span> <span class="c1">// 当前m的内存缓存
</span><span class="c1"></span>    <span class="nx">lockedg</span>       <span class="o">*</span><span class="nx">g</span> <span class="c1">// 锁定g在当前m上执行，而不会切换到其他m
</span><span class="c1"></span>    <span class="nx">createstack</span>   <span class="p">[</span><span class="mi">32</span><span class="p">]</span><span class="kt">uintptr</span> <span class="c1">// thread创建的栈
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>结构体 M 中有两个 G 是需要关注一下的，一个是 curg，代表结构体 M 当前绑定的结构体 G。另一个是g0，是带有调度栈的 goroutine，这是一个比较特殊的 goroutine。普通的 goroutine 的栈是在堆上分配的可增长的栈，而 g0 的栈是 M 对应的线程的栈。所有调度相关的代码，会先切换到该 goroutine 的栈中再执行。也就是说线程的栈也是用的 g 实现，而不是使用的 OS 的。</p>
<p><strong>P</strong> 代表一个处理器，每一个运行的 M 都必须绑定一个 P，就像线程必须在么一个 CPU 核上执行一样，由 P 来调度 G 在 M 上的运行，P 的个数就是 GOMAXPROCS (最大256)，启动时固定的，一般不修改；M 的个数和 P 的个数不一定一样多 (会有休眠的 M 或者不需要太多的 M) (最大10000)；每一个 P 保存着本地 G 任务队列，也有一个全局 G 任务队列。</p>
<p>其数据结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span> <span class="nx">mutex</span>

	<span class="nx">id</span>          <span class="kt">int32</span>
	<span class="cm">/*
</span><span class="cm">        Pidle：没有关联的M
</span><span class="cm">        Prunning：已和某个M关联
</span><span class="cm">        Psyscall：当前P中的被运行的那个G正在进行系统调用
</span><span class="cm">        Pgcstop： 系统正在GC
</span><span class="cm">        Pdead: 当前P不再使用
</span><span class="cm">	*/</span>
	<span class="nx">status</span>      <span class="kt">uint32</span>     <span class="c1">// 状态，可以为pidle/prunning/...
</span><span class="c1"></span>	<span class="nx">link</span>        <span class="nx">puintptr</span>
	<span class="nx">schedtick</span>   <span class="kt">uint32</span>     <span class="c1">// 每调度一次加1
</span><span class="c1"></span>	<span class="nx">syscalltick</span> <span class="kt">uint32</span>     <span class="c1">// 每一次系统调用加1
</span><span class="c1"></span>	<span class="nx">sysmontick</span>  <span class="nx">sysmontick</span>
	<span class="nx">m</span>           <span class="nx">muintptr</span>   <span class="c1">// 回链到关联的m
</span><span class="c1"></span>	<span class="nx">mcache</span>      <span class="o">*</span><span class="nx">mcache</span>
	<span class="nx">racectx</span>     <span class="kt">uintptr</span>

	<span class="nx">goidcache</span>    <span class="kt">uint64</span> <span class="c1">// goroutine的ID的缓存
</span><span class="c1"></span>	<span class="nx">goidcacheend</span> <span class="kt">uint64</span>

	<span class="c1">// 可运行的goroutine的队列
</span><span class="c1"></span>	<span class="nx">runqhead</span> <span class="kt">uint32</span>
	<span class="nx">runqtail</span> <span class="kt">uint32</span>
	<span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>

	<span class="nx">runnext</span> <span class="nx">guintptr</span> <span class="c1">// 下一个运行的g
</span><span class="c1"></span>
	<span class="nx">sudogcache</span> <span class="p">[]</span><span class="o">*</span><span class="nx">sudog</span>
	<span class="nx">sudogbuf</span>   <span class="p">[</span><span class="mi">128</span><span class="p">]</span><span class="o">*</span><span class="nx">sudog</span>

	<span class="nx">palloc</span> <span class="nx">persistentAlloc</span> <span class="c1">// per-P to avoid mutex
</span><span class="c1"></span>
	<span class="nx">pad</span> <span class="p">[</span><span class="nx">sys</span><span class="p">.</span><span class="nx">CacheLineSize</span><span class="p">]</span><span class="kt">byte</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中 P 的状态有 Pidle / Prunning / Psyscall / Pgcstop / Pdead；在其内部队列 runqhead 里面有可运行的 goroutine，P 优先从内部获取执行的 g，这样能够提高效率。</p>
<p>除此之外，还有一个数据结构需要在这里提及，就是 <strong>schedt</strong>，可以看做是一个全局的调度者：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">schedt</span> <span class="kd">struct</span> <span class="p">{</span>

    <span class="nx">lock</span> <span class="nx">mutex</span>

    <span class="nx">midle</span>        <span class="nx">muintptr</span> <span class="c1">// 空闲M链表
</span><span class="c1"></span>    <span class="nx">nmidle</span>       <span class="kt">int32</span>    <span class="c1">// 空闲M数量
</span><span class="c1"></span>    <span class="nx">nmidlelocked</span> <span class="kt">int32</span>    <span class="c1">// 被锁住的M的数量
</span><span class="c1"></span>    <span class="nx">mnext</span>        <span class="kt">int64</span>    <span class="c1">// 已创建M的数量，以及下一个M ID
</span><span class="c1"></span>    <span class="nx">maxmcount</span>    <span class="kt">int32</span>    <span class="c1">// 允许创建最大的M数量
</span><span class="c1"></span>    <span class="nx">nmsys</span>        <span class="kt">int32</span>    <span class="c1">// 不计入死锁的M数量
</span><span class="c1"></span>    <span class="nx">nmfreed</span>      <span class="kt">int64</span>    <span class="c1">// 累计释放M的数量
</span><span class="c1"></span>
    <span class="nx">pidle</span>      <span class="nx">puintptr</span> <span class="c1">// 空闲的P链表
</span><span class="c1"></span>    <span class="nx">npidle</span>     <span class="kt">uint32</span>   <span class="c1">// 空闲的P数量
</span><span class="c1"></span>
    <span class="nx">runq</span>     <span class="nx">gQueue</span> <span class="c1">// 全局runnable的G队列
</span><span class="c1"></span>    <span class="nx">runqsize</span> <span class="kt">int32</span>  <span class="c1">// 全局runnable的G数量
</span><span class="c1"></span>
    <span class="c1">// Global cache of dead G&#39;s.
</span><span class="c1"></span>    <span class="nx">gFree</span> <span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">lock</span>    <span class="nx">mutex</span>
        <span class="nx">stack</span>   <span class="nx">gList</span> <span class="c1">// Gs with stacks
</span><span class="c1"></span>        <span class="nx">noStack</span> <span class="nx">gList</span> <span class="c1">// Gs without stacks
</span><span class="c1"></span>        <span class="nx">n</span>       <span class="kt">int32</span>
    <span class="p">}</span>

    <span class="c1">// freem is the list of m&#39;s waiting to be freed when their
</span><span class="c1"></span>    <span class="c1">// m.exited is set. Linked through m.freelink.
</span><span class="c1"></span>    <span class="nx">freem</span> <span class="o">*</span><span class="nx">m</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>大多数需要的信息都已放在了结构体 M、G 和 P 中，schedt 结构体只是一个壳。</p>
<p>可以看到，其中有 M 的 idle 队列，P 的 idle 队列，以及一个全局的就绪的 G 队列。</p>
<p>schedt 结构体中的 Lock 是非常必须的，如果 M 或 P 等做一些非局部的操作，它们一般需要先锁住调度器。</p>
<h2 id="三goroutines-是怎么工作的-">三、Goroutines 是怎么工作的 ？</h2>
<h3 id="go-程序启动过程">Go 程序启动过程</h3>
<hr>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// main.go
</span><span class="c1"></span><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
	<span class="s">&#34;fmt&#34;</span>
<span class="p">)</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;hello world&#34;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 <strong>gdb</strong> 跟踪查看程序启动流程
通过设置断点，可以定位到每个方法的源码文件路径</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">$ go build main.go
$ gdb main

GNU gdb <span class="o">(</span>GDB<span class="o">)</span> 8.3.50.20190416-git
Copyright <span class="o">(</span>C<span class="o">)</span> <span class="m">2019</span> Free Software Foundation, Inc.
<span class="o">(</span>gdb<span class="o">)</span> info files
Symbols from <span class="s2">&#34;/Users/kuangren/Desktop/go_project/main&#34;</span>.
Local <span class="nb">exec</span> file:
	<span class="sb">`</span>/Users/kuangren/Desktop/go_project/main<span class="err">&#39;</span>, file <span class="nb">type</span> mach-o-x86-64.
	Entry point: 0x105cda0
	0x0000000001001000 - 0x000000000109d109 is .text
	0x000000000109d120 - 0x00000000010ec2f6 is __TEXT.__rodata
	0x00000000010ec300 - 0x00000000010ec426 is __TEXT.__symbol_stub1
	...

<span class="o">(</span>gdb<span class="o">)</span> b *0x105cda0
Breakpoint <span class="m">1</span> at 0x1051540: file /usr/local/go/src/runtime/rt0_darwin_amd64.s, line 8.
<span class="o">(</span>gdb<span class="o">)</span> b runtime.rt0_go
Breakpoint <span class="m">2</span> at 0x104dd30: file /usr/local/go/src/runtime/asm_amd64.s, line 12.
</code></pre></td></tr></table>
</div>
</div><p>对应找到 asm_amd64.s</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span><span class="lnt">92
</span><span class="lnt">93
</span><span class="lnt">94
</span><span class="lnt">95
</span><span class="lnt">96
</span><span class="lnt">97
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="c1">// src/runtime/asm_amd64.s
</span><span class="c1">// 省略头文件
</span><span class="c1"></span>
<span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">rt0_go</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span>
    <span class="c1">// 省略命令行参数处理的代码
</span><span class="c1"></span>
	<span class="c1">// 全局的g0实例地址放到DI
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
	<span class="nf">LEAQ</span>	<span class="p">(</span><span class="o">-</span><span class="mi">64</span><span class="o">*</span><span class="mi">1024</span><span class="o">+</span><span class="mi">104</span><span class="p">)(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">BX</span>
	<span class="c1">// 初始化全局g0实例的stackguard0\stackguard1\stack这三个字段
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard0</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="nf">g_stackguard1</span><span class="p">(</span><span class="nx">DI</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nx">BX</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_lo</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nx">SP</span><span class="p">,</span> <span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_hi</span><span class="p">)(</span><span class="nx">DI</span><span class="p">)</span>

	<span class="c1">// 省略一系列与CPU相关的特性标志位检查的代码
</span><span class="c1"></span>
<span class="nx">nocpuinfo</span><span class="p">:</span>
    <span class="c1">// 到这里与CPU相关的检查已设置完毕
</span><span class="c1"></span>	<span class="c1">// if there is an _cgo_init, call it.
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nf">_cgo_init</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="c1">// 没开启cgo的话就跳转到needtls标签继续执行
</span><span class="c1"></span>	<span class="nx">TESTQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="nx">AX</span>
	<span class="nx">JZ</span>	<span class="nx">needtls</span>
	<span class="c1">// g0 already in DI
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">DI</span><span class="p">,</span> <span class="nx">CX</span>	<span class="c1">// Win64 uses CX for first parameter
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">setg_gcc</span><span class="p">&lt;&gt;(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">SI</span>
	<span class="nx">CALL</span>	<span class="nx">AX</span>

	<span class="c1">// _cgo_init 执行完，重新更新下stackguard0/stackguard1
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>
	<span class="nf">MOVQ</span>	<span class="p">(</span><span class="nx">g_stack</span><span class="o">+</span><span class="nx">stack_lo</span><span class="p">)(</span><span class="nx">CX</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">ADDQ</span>	<span class="err">$</span><span class="nx">const__StackGuard</span><span class="p">,</span> <span class="nx">AX</span>
	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="nf">g_stackguard0</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="nf">g_stackguard1</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>

<span class="nx">needtls</span><span class="p">:</span>
	<span class="c1">// 省略部分用于预编译的代码，因为本文的测试工程环境不会执行这些代码
</span><span class="c1"></span>
	<span class="c1">// 取全局m0实例的tls字段地址放在DI，并进行设置
</span><span class="c1"></span>	<span class="nx">LEAQ</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">DI</span>
	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">settls</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// store through it, to make sure it works
</span><span class="c1"></span>	<span class="c1">// 经过上面的settls后，需要验证get_tls和g()作用是否符合预期。失败的话，就引发abort
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="mh">0x123</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nx">m0</span><span class="o">+</span><span class="nf">m_tls</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>
	<span class="nx">CMPQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="err">$</span><span class="mh">0x123</span>
	<span class="nx">JEQ</span> <span class="mi">2</span><span class="p">(</span><span class="nx">PC</span><span class="p">)</span>
	<span class="nx">MOVL</span>	<span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span>	<span class="c1">// abort
</span><span class="c1"></span>
<span class="nx">ok</span><span class="p">:</span>
	<span class="c1">// 验证成功后，把全局g0实例放进tls，并且将g0和m0互相引用
</span><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">LEAQ</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">g0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">CX</span>
	<span class="nx">MOVQ</span>	<span class="nx">CX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
	<span class="nx">LEAQ</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">m0</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>

	<span class="c1">// save m-&gt;g0 = g0
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">CX</span><span class="p">,</span> <span class="nf">m_g0</span><span class="p">(</span><span class="nx">AX</span><span class="p">)</span>
	<span class="c1">// save m0 to g0-&gt;m
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="nf">g_m</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>

	<span class="nx">CLD</span>				<span class="c1">// convention is D is always left cleared
</span><span class="c1"></span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">check</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="nx">MOVL</span>	<span class="mi">16</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>		<span class="c1">// copy argc
</span><span class="c1"></span>	<span class="nx">MOVL</span>	<span class="nx">AX</span><span class="p">,</span> <span class="mi">0</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
	<span class="nx">MOVQ</span>	<span class="mi">24</span><span class="p">(</span><span class="nx">SP</span><span class="p">),</span> <span class="nx">AX</span>		<span class="c1">// copy argv
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="nx">AX</span><span class="p">,</span> <span class="mi">8</span><span class="p">(</span><span class="nx">SP</span><span class="p">)</span>
	<span class="c1">// 执行文件的绝对路径初始化
</span><span class="c1"></span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">args</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="c1">// cpu个数和内存页大小初始化
</span><span class="c1"></span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">osinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="c1">// 命令行参数、环境变量、gc、栈空间、内存管理、所有P实例、HASH算法等初始化
</span><span class="c1"></span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">schedinit</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="c1">// create a new goroutine to start program
</span><span class="c1"></span>	<span class="c1">// runtime.main函数地址放进AX
</span><span class="c1"></span>	<span class="nx">MOVQ</span>	<span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">mainPC</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">AX</span>		<span class="c1">// entry
</span><span class="c1"></span>	<span class="c1">// 推进栈
</span><span class="c1"></span>	<span class="nx">PUSHQ</span>	<span class="nx">AX</span>
	<span class="nx">PUSHQ</span>	<span class="err">$</span><span class="mi">0</span>			<span class="c1">// arg size
</span><span class="c1"></span>	<span class="c1">// 新建一个goroutine，该goroutine绑定runtime.main，放在P的本地队列，等待调度
</span><span class="c1"></span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">newproc</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
	<span class="nx">POPQ</span>	<span class="nx">AX</span>
	<span class="nx">POPQ</span>	<span class="nx">AX</span>

	<span class="c1">// start this M
</span><span class="c1"></span>	<span class="c1">// 启动M，开始调度goroutine
</span><span class="c1"></span>	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">mstart</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>

	<span class="nx">MOVL</span>	<span class="err">$</span><span class="mh">0xf1</span><span class="p">,</span> <span class="mh">0xf1</span>  <span class="c1">// crash
</span><span class="c1"></span>	<span class="nx">RET</span>

<span class="nx">DATA</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nx">mainPC</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="err">$</span><span class="nx">runtime</span><span class="err">·</span><span class="nf">main</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p>按顺序总结下 runtime.rt0_go 主要做哪些事：</p>
<ol>
<li>检查运行平台的 CPU，设置好程序运行需要相关标志。</li>
<li>TLS 的初始化。</li>
<li>runtime.args、runtime.osinit、runtime.schedinit 三个方法做好程序运行需要的各种变量与调度器。</li>
<li>runtime.newproc 创建新的 goroutine 用于绑定用户写的 main 方法。</li>
<li>runtime.mstart 开始 goroutine 的调度。</li>
</ol>
<h3 id="goroutine-的运行过程">goroutine 的运行过程</h3>
<hr>
<p>所有的 goroutine 都是由函数<code>newproc</code>来创建的，但是由于该函数不能调用分段栈，最后真正调用的是<code>newproc1</code>。在<code>newproc1</code>中主要进行如下动作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="o">*</span><span class="kt">uint8</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">nret</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

	<span class="k">if</span> <span class="nx">fn</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">throwing</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// do not dump full stacks
</span><span class="c1"></span>		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;go of nil func value&#34;</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">++</span> <span class="c1">// disable preemption because it can be holding p in a local var
</span><span class="c1"></span>	<span class="nx">siz</span> <span class="o">:=</span> <span class="nx">narg</span> <span class="o">+</span> <span class="nx">nret</span>
	<span class="nx">siz</span> <span class="p">=</span> <span class="p">(</span><span class="nx">siz</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="mi">7</span>

	<span class="c1">// 判断函数参数和返回值的大小是否超出栈大小
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">siz</span> <span class="o">&gt;=</span> <span class="nx">_StackMin</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span><span class="o">-</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc: function arguments too large for new goroutine&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
	<span class="c1">// 拿到一个free的goroutine，没有就从全局调度器拿
</span><span class="c1"></span>	<span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
	<span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 新建g实例，栈大小2K
</span><span class="c1"></span>		<span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
		<span class="c1">// g实例状态改成dead
</span><span class="c1"></span>		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
		<span class="c1">// 将此g实例加入全局的g队列里
</span><span class="c1"></span>		<span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="c1">// publishes with a g-&gt;status of Gdead so GC scanner doesn&#39;t look at uninitialized stack.
</span><span class="c1"></span>	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: newg missing stack&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="nf">readgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">_Gdead</span> <span class="p">{</span>
		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;newproc1: new g is not Gdead&#34;</span><span class="p">)</span>
	<span class="p">}</span>

	<span class="nx">totalSize</span> <span class="o">:=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span> <span class="c1">// extra space in case of reads slightly beyond frame
</span><span class="c1"></span>	<span class="nx">totalSize</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">totalSize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">SpAlign</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>                  <span class="c1">// align to spAlign
</span><span class="c1"></span>	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span>
	<span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>

	<span class="k">if</span> <span class="nx">usesLR</span> <span class="p">{</span>
        <span class="c1">// 使用了LR寄存器存放函数调用完毕后的返回地址
</span><span class="c1"></span>		<span class="c1">// caller&#39;s LR
</span><span class="c1"></span>		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
		<span class="nf">prepGoExitFrame</span><span class="p">(</span><span class="nx">sp</span><span class="p">)</span>
		<span class="nx">spArg</span> <span class="o">+=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">narg</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">spArg</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">))</span>
		<span class="k">if</span> <span class="nx">writeBarrier</span><span class="p">.</span><span class="nx">needed</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">gcscandone</span> <span class="p">{</span>
			<span class="nx">f</span> <span class="o">:=</span> <span class="nf">findfunc</span><span class="p">(</span><span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span><span class="p">)</span>
			<span class="nx">stkmap</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">stackmap</span><span class="p">)(</span><span class="nf">funcdata</span><span class="p">(</span><span class="nx">f</span><span class="p">,</span> <span class="nx">_FUNCDATA_ArgsPointerMaps</span><span class="p">))</span>
			<span class="nx">bv</span> <span class="o">:=</span> <span class="nf">stackmapdata</span><span class="p">(</span><span class="nx">stkmap</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
			<span class="nf">bulkBarrierBitmap</span><span class="p">(</span><span class="nx">spArg</span><span class="p">,</span> <span class="nx">spArg</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">bv</span><span class="p">.</span><span class="nx">bytedata</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="c1">// 将newg.sched结构的内存置0
</span><span class="c1"></span>	<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
	<span class="c1">// g实例的调度现场保存SP寄存器
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="c1">// g实例自身也保存SP寄存器
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>
	<span class="c1">// g实例的调度现场保存goexit函数的PC寄存器，这样goroutine执行完后都能做好回收
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span> <span class="c1">// +PCQuantum so that previous instruction is in same function
</span><span class="c1"></span>	<span class="c1">// g实例的调度现场关联上对应的g
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
	<span class="c1">// g实例的调度现场保存真正待执行函数的PC寄存器
</span><span class="c1"></span>	<span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
	<span class="c1">// g实例保存go语句的PC寄存器位置
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">gopc</span> <span class="p">=</span> <span class="nx">callerpc</span>
	<span class="c1">// g实例保存待执行函数的PC寄存器位置
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>

	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="c1">// 如果是在goroutine中再new 一个goroutine，就会有labels?
</span><span class="c1"></span>		<span class="nx">newg</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span><span class="p">.</span><span class="nx">labels</span>
	<span class="p">}</span>

	<span class="c1">// 存在一些go自己创建的goroutine，如果是就在全局调度器里把数量记录下来
</span><span class="c1"></span>	<span class="k">if</span> <span class="nf">isSystemGoroutine</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">ngsys</span><span class="p">,</span> <span class="o">+</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 设置该goroutine不能被gc扫
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">gcscanvalid</span> <span class="p">=</span> <span class="kc">false</span>
	<span class="c1">// 设置goroutine状态为可运行
</span><span class="c1"></span>	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>

	<span class="c1">// 检查当前p实例里的goroutine id缓存列表是否已经用完，是的话就从全局调度器那儿再获取_GoidCacheBatch个
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">==</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">{</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="p">=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd64</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">goidgen</span><span class="p">,</span> <span class="nx">_GoidCacheBatch</span><span class="p">)</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">-=</span> <span class="nx">_GoidCacheBatch</span> <span class="o">-</span> <span class="mi">1</span>
		<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcacheend</span> <span class="p">=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span> <span class="o">+</span> <span class="nx">_GoidCacheBatch</span>
	<span class="p">}</span>
	<span class="c1">// 设置goroutine id
</span><span class="c1"></span>	<span class="nx">newg</span><span class="p">.</span><span class="nx">goid</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="p">)</span>
	<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
		<span class="nx">newg</span><span class="p">.</span><span class="nx">racectx</span> <span class="p">=</span> <span class="nf">racegostart</span><span class="p">(</span><span class="nx">callerpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
		<span class="nf">traceGoCreate</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 把新建的G推进当前P的本地队列，并提优设置为下一个可运行的G
</span><span class="c1"></span>	<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">newg</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>

	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">mainStarted</span> <span class="p">{</span>
		<span class="c1">// main方法启动后才进入此if块。唤醒一个空闲的P，如果没有M则创建一个
</span><span class="c1"></span>		<span class="nf">wakep</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span><span class="o">--</span>
	<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">locks</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">{</span> <span class="c1">// restore the preemption request in case we&#39;ve cleared it in newstack
</span><span class="c1"></span>		<span class="nx">_g_</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">stackPreempt</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">newg</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>做了哪些事情：</p>
<ol>
<li>从 TLS 拿到当前运行的 G 实例，并且使绑定到当前线程的 M 实例不可抢占。</li>
<li>从 M 实例上取到 P 实例，如果 P 实例本地上有 free goroutine 就拿过去，没有就到全局调度器那拿一些过来。如果这两个都没有，就按照最低栈大小2K new 一个 G 实例（即goroutine）。</li>
<li>然后设置好 G 实例上的各种寄存器的信息，SP、PC等。</li>
<li>将 G 实例的状态变更为 Grunnable，放到 P 实例的本地可运行队列里等待调度执行，若队列满了，就把一半的 G 移到全局调度器下。</li>
<li>释放 M 实例的不可抢占状态。返回新的 G 实例。</li>
</ol>
<p>这个绑定只要 M 没有突破上限 GOMAXPROCS，就拿一个 M 绑定一个 G。</p>
<p>如果 M 的 waiting 队列中有就从队列中拿，否则就要新建一个 M，调用<code>newm</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">newm</span><span class="p">(</span><span class="nx">fn</span> <span class="kd">func</span><span class="p">(),</span> <span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">mp</span> <span class="o">:=</span> <span class="nf">allocm</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
    <span class="nx">mp</span><span class="p">.</span><span class="nx">nextp</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
    <span class="nx">mp</span><span class="p">.</span><span class="nx">sigmask</span> <span class="p">=</span> <span class="nx">initSigmask</span>
    <span class="nx">execLock</span><span class="p">.</span><span class="nf">rlock</span><span class="p">()</span>
    <span class="nf">newosproc</span><span class="p">(</span><span class="nx">mp</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">mp</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span><span class="p">))</span>
    <span class="nx">execLock</span><span class="p">.</span><span class="nf">runlock</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>该函数其实就是创建一个 M，跟 newproc 有些相似，M 在底层就是一个线程的创建，也就是 newosproc func -&gt; bsdthread_create func -&gt; runtime.clone：</p>
<p><code>clone(cloneFlags,stk,unsafe.Pointer(mp),unsafe.Pointer(mp.g0),unsafe.Pointer(funcPC(mstart)))</code></p>
<p>M 创建好之后，线程的入口是 mstart，最后调用的即是 mstart1：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mstart1</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
    <span class="nf">gosave</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
    <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">g0</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="nf">asminit</span><span class="p">()</span>
    <span class="nf">minit</span><span class="p">()</span>

    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span> <span class="o">==</span> <span class="o">&amp;</span><span class="nx">m0</span> <span class="p">{</span>
        <span class="nf">initsig</span><span class="p">(</span><span class="kc">false</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="nx">fn</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">mstartfn</span><span class="p">;</span> <span class="nx">fn</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">fn</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nf">schedule</span><span class="p">()</span> <span class="c1">// 最重要
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>里面最重要的就是 <strong>schedule</strong> 了，在 schedule 中的动作大体就是找到一个等待运行的 g，然后然后搬到 m 上，设置其状态为 Grunning，直接切换到 g 的上下文环境，恢复 g 的执行。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>

    <span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nf">stoplockedm</span><span class="p">()</span>
        <span class="nf">execute</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">lockedg</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="c1">// Never returns.
</span><span class="c1"></span>    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><code>schedule</code>函数获取 g -&gt; 必要时休眠 -&gt; 唤醒后继续获取 -&gt; <code>execute</code>函数执行 g -&gt; 执行后返回到 goexit -&gt; 重新执行<code>schedule</code>函数</p>
<p>g 所经历的几个主要的过程就是：Gwaiting -&gt; Grunnable -&gt; Grunning。</p>
<p>经历了创建，到挂在就绪队列，到从就绪队列拿出并运行整个过程。</p>
<p>引入了 struct m 这层抽象。m 就是这里的 worker，但不是线程。</p>
<p>处理系统调用中的 m 不会占用 mcpu 数量，只有干事的 m 才会对应到线程，当 mcpu 数量少于 GOMAXPROCS 时可以一直开新的线程干活。</p>
<p>而 goroutine 的执行则是在 m 和 g 都满足之后通过 schedule 切换上下文进入的。</p>
<h3 id="抢占式调度">抢占式调度</h3>
<hr>
<p>当有很多 goroutine 需要执行的时候，是怎么调度的 ?</p>
<p>上面说的 P 还没有出场呢，在<code>runtime.main</code>中会创建一个额外 m 运行<code>sysmon</code>函数，抢占就是在 sysmon 中实现的。</p>
<p>sysmon 会进入一个无限循环，第一轮回休眠 20 us，之后每次休眠时间倍增，最终每一轮都会休眠 10 ms。</p>
<p>sysmon 有下面几个处理：</p>
<ul>
<li>netpool（获取 fd 事件）</li>
<li>retake（抢占）</li>
<li>forcegc（按时间强制执行 gc）</li>
<li>scavenge heap（释放自由列表中多余的项减少内存占用）</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">sysmon</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">lasttrace</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="nx">idle</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// how many cycles in succession we had not wokeup somebody
</span><span class="c1"></span>    <span class="nx">delay</span> <span class="o">:=</span> <span class="nb">uint32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">for</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nx">idle</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="c1">// start with 20us sleep...
</span><span class="c1"></span>            <span class="nx">delay</span> <span class="p">=</span> <span class="mi">20</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">idle</span> <span class="p">&gt;</span> <span class="mi">50</span> <span class="p">{</span> <span class="c1">// start doubling the sleep after 1ms...
</span><span class="c1"></span>            <span class="nx">delay</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="nx">delay</span> <span class="p">&gt;</span> <span class="mi">10</span><span class="o">*</span><span class="mi">1000</span> <span class="p">{</span> <span class="c1">// up to 10ms
</span><span class="c1"></span>            <span class="nx">delay</span> <span class="p">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1000</span>
        <span class="p">}</span>
        <span class="nf">usleep</span><span class="p">(</span><span class="nx">delay</span><span class="p">)</span>

        <span class="o">......</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>里面的函数<code>retake</code>负责抢占：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">retake</span><span class="p">(</span><span class="nx">now</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">uint32</span> <span class="p">{</span>
    <span class="nx">n</span> <span class="o">:=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">gomaxprocs</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">allp</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nx">_p_</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="nx">pd</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">sysmontick</span>
        <span class="nx">s</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span>
        <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Psyscall</span> <span class="p">{</span>
            <span class="c1">// 如果p的syscall时间超过一个sysmon tick则抢占该p
</span><span class="c1"></span>            <span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
                <span class="nx">pd</span><span class="p">.</span><span class="nx">syscalltick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
                <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span> <span class="p">=</span> <span class="nx">now</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nf">runqempty</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span><span class="o">+</span><span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">syscallwhen</span><span class="o">+</span><span class="mi">10</span><span class="o">*</span><span class="mi">1000</span><span class="o">*</span><span class="mi">1000</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="nf">incidlelocked</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Cas</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span> <span class="nx">s</span><span class="p">,</span> <span class="nx">_Pidle</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="nx">trace</span><span class="p">.</span><span class="nx">enabled</span> <span class="p">{</span>
                    <span class="nf">traceGoSysBlock</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
                    <span class="nf">traceProcStop</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
                <span class="p">}</span>
                <span class="nx">n</span><span class="o">++</span>
                <span class="nx">_p_</span><span class="p">.</span><span class="nx">syscalltick</span><span class="o">++</span>
                <span class="nf">handoffp</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="nf">incidlelocked</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">s</span> <span class="o">==</span> <span class="nx">_Prunning</span> <span class="p">{</span>
            <span class="c1">// 如果G运行时间过长，则抢占该G
</span><span class="c1"></span>            <span class="nx">t</span> <span class="o">:=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">t</span> <span class="p">{</span>
                <span class="nx">pd</span><span class="p">.</span><span class="nx">schedtick</span> <span class="p">=</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span>
                <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span> <span class="p">=</span> <span class="nx">now</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="nx">pd</span><span class="p">.</span><span class="nx">schedwhen</span><span class="o">+</span><span class="nx">forcePreemptNS</span> <span class="p">&gt;</span> <span class="nx">now</span> <span class="p">{</span>
                <span class="k">continue</span>
            <span class="p">}</span>
            <span class="nf">preemptone</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">n</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>枚举所有的 P，如果 P 在系统调用中（Psyscall），且经过了一次 sysmon 循环（20us ~ 10ms），则抢占这个 P，调用 handoffp 解除 M 和 P 之间的关联，如果 P 在运行中（_Prunning），且经过了一次 sysmon 循环并且 G 运行时间超过 forcePreemptNS（10ms），则抢占这个 P，并设置 g.preempt = true，g.stackguard0 = stackPreempt。</p>
<p>为什么设置了 stackguard 就可以实现抢占?</p>
<p>因为这个值用于检查当前栈空间是否足够，go 函数的开头会比对这个值判断是否需要扩张栈。</p>
<p><code>newstack</code>函数判断 g.stackguard0 等于 stackPreempt，就知道这是抢占触发的，这时会再检查一遍是否要抢占。</p>
<p><strong>抢占机制保证了不会有一个 G 长时间的运行导致其他 G 无法运行的情况发生</strong>。</p>
<h3 id="总结">总结</h3>
<hr>
<p>相比大多数并行设计模型，Go 比较优势的设计就是 P 上下文这个概念的出现，如果只有 G 和 M 的对应关系，那么当 G 阻塞在 IO 上的时候，M 是没有实际在工作的，这样造成了资源的浪费，没有了 P，那么所有 G 的列表都放在全局，这样导致临界区太大，对多核调度造成极大影响。</p>
<p>而 goroutine 使用上面的特点，感觉既可以用来做密集的多核计算，又可以做高并发的 IO 应用，做 IO 应用的时候，写起来感觉和对程序员最友好的同步阻塞一样，而实际上由于 runtime 的调度，底层是以同步非阻塞的方式在运行（即 IO 多路复用）。</p>
<p>所以说保护现场的抢占式调度和 G 被阻塞后传递给其他 m 调用的核心思想，使得 goroutine 的产生。</p>
<h2 id="四参考资料">四、参考资料</h2>
<hr>
<ul>
<li><a href="https://blog.nindalf.com/posts/how-goroutines-work/">How Goroutines Work</a></li>
<li><a href="https://www.sciencedirect.com/topics/computer-science/thread-scheduler">Thread Scheduler</a></li>
<li><a href="https://morsmachine.dk/go-scheduler">The Go scheduler</a></li>
<li><a href="https://www.youtube.com/watch?v=YHRO5WQGh0k&amp;list=PLhrlUMtJvak5wx2I0nxkMKWQuolCgqmGz">GopherCon 2018: Kavya Joshi - The Scheduler Saga</a></li>
<li><a href="https://medium.com/@ankur_anand/illustrated-tales-of-go-runtime-scheduler-74809ef6d19b">Illustrated Tales of Go Runtime Scheduler.</a></li>
<li><a href="%5Bhttps://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#654-%E5%88%9B%E5%BB%BA-goroutine%5D(https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#654-%E5%88%9B%E5%BB%BA-goroutine)">Go 语言设计与实现</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/95056679">腾讯技术工程</a></li>
<li><a href="https://juejin.im/post/5d6cfa13518825267a75685e">深度解密 Go 语言之 scheduler</a></li>
<li><a href="https://blog.csdn.net/gatieme/article/details/51892437">线程的三种实现方式-内核级线程, 用户级线程和混合型线程</a></li>
<li><a href="https://taohuawu.club/high-performance-implementation-of-goroutine-pool">Goroutine 并发调度模型深度解析之手撸一个高性能 goroutine 池</a></li>
<li><a href="%5Bhttps://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/%5D(https://cbsheng.github.io/posts/%E6%8E%A2%E7%B4%A2golang%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/)">探索 golang 程序启动过程</a></li>
<li><a href="https://www.cnblogs.com/sunsky303/p/9705727.html">深入 Golang 调度器之 GMP 模型</a></li>
</ul>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">rubinera1n</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2020-07-06
      
        <a href="https://github.com/rubinera1n/blogs/commit/f752eedd696982c3dad2dcef15b42548c6ef1f5e" title="update">
          (f752eed)
        </a>
        
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://blog.xiufuguo.com/tags/golang/">golang</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/leetcode/tags/tree/construct-binary-tree-from-inorder-and-postorder-traversal/">
            <span class="next-text nav-default">[LeetCode] 106. Construct Binary Tree from Inorder and Postorder Traversal</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "rubinera1n/comments"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:rubinera1n@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://www.linkedin.com/in/hsiufukuo" rel="me noopener" class="iconfont"
      title="linkedin"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M872.405333 872.618667h-151.637333v-237.610667c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333 0-91.136 61.653333-91.136 125.397334v241.792H398.976V384h145.664v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667 0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667 0 0 1-88.021333-88.106666 88.064 88.064 0 1 1 88.021333 88.106666z m76.032 555.477334H151.68V384h152.064v488.618667zM948.266667 0H75.562667C33.792 0 0 33.024 0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667 0 948.138667 0h0.128z"></path>
</svg>

    </a>
  
    <a href="https://github.com/rubinera1n" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://blog.xiufuguo.com/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        rubinera1n
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
