<!DOCTYPE html>
<html lang="en" itemscope itemtype="http://schema.org/WebPage">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Thread - Rubinera1n&#39;s Blog</title>
  

<meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta name="MobileOptimized" content="width"/>
<meta name="HandheldFriendly" content="true"/>


<meta name="applicable-device" content="pc,mobile">

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">

<meta name="mobile-web-app-capable" content="yes">

<meta name="author" content="rubinera1n" />
  <meta name="description" content="1. 线程的基本概念 线程英文单词是 thread。 说到线程不得不提到”进程”，一个进程代表计算机中实际跑起来的一个程序，在现代操作系统的保护模式下" />

  <meta name="keywords" content="Hugo, blog, rubinera1n" />






<meta name="generator" content="Hugo 0.70.0" />


<link rel="canonical" href="https://blog.xiufuguo.com/post/linux/thread/" />





<link rel="icon" href="/favicon.ico" />











<link rel="stylesheet" href="/sass/jane.min.fa3d941d1d0e0ddc985804227feabffea55c89883eb0af34e0532a7ae9135151.css" integrity="sha256-&#43;j2UHR0ODdyYWAQif&#43;q//qVciYg&#43;sK804FMqeukTUVE=" media="screen" crossorigin="anonymous">





<meta property="og:title" content="Thread" />
<meta property="og:description" content="1. 线程的基本概念 线程英文单词是 thread。 说到线程不得不提到”进程”，一个进程代表计算机中实际跑起来的一个程序，在现代操作系统的保护模式下" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://blog.xiufuguo.com/post/linux/thread/" />
<meta property="article:published_time" content="2020-06-26T04:34:52+08:00" />
<meta property="article:modified_time" content="2020-07-05T00:23:18+08:00" />
<meta itemprop="name" content="Thread">
<meta itemprop="description" content="1. 线程的基本概念 线程英文单词是 thread。 说到线程不得不提到”进程”，一个进程代表计算机中实际跑起来的一个程序，在现代操作系统的保护模式下">
<meta itemprop="datePublished" content="2020-06-26T04:34:52&#43;08:00" />
<meta itemprop="dateModified" content="2020-07-05T00:23:18&#43;08:00" />
<meta itemprop="wordCount" content="20412">



<meta itemprop="keywords" content="linux," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Thread"/>
<meta name="twitter:description" content="1. 线程的基本概念 线程英文单词是 thread。 说到线程不得不提到”进程”，一个进程代表计算机中实际跑起来的一个程序，在现代操作系统的保护模式下"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->




</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">rubinera1n</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/">Home</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/post/">Archives</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/tags/">Tags</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/categories/">Categories</a>
          
        
      </li><li class="mobile-menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/about/">About</a>
          
        
      </li>
    

    
  </ul>
</nav>


  
    






  <link rel="stylesheet" href="/lib/photoswipe/photoswipe.min.css" />
  <link rel="stylesheet" href="/lib/photoswipe/default-skin/default-skin.min.css" />




<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

<div class="pswp__bg"></div>

<div class="pswp__scroll-wrap">
    
    <div class="pswp__container">
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
      <div class="pswp__item"></div>
    </div>
    
    <div class="pswp__ui pswp__ui--hidden">
    <div class="pswp__top-bar">
      
      <div class="pswp__counter"></div>
      <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
      <button class="pswp__button pswp__button--share" title="Share"></button>
      <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
      <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
      
      
      <div class="pswp__preloader">
        <div class="pswp__preloader__icn">
          <div class="pswp__preloader__cut">
            <div class="pswp__preloader__donut"></div>
          </div>
        </div>
      </div>
    </div>
    <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
      <div class="pswp__share-tooltip"></div>
    </div>
    <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
    </button>
    <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
    </button>
    <div class="pswp__caption">
      <div class="pswp__caption__center"></div>
    </div>
    </div>
    </div>
</div>

  

  

  

  <header id="header" class="header container">
    <div class="logo-wrapper">
  <a href="/" class="logo">
    
      rubinera1n
    
  </a>
</div>

<nav class="site-navbar">
  <ul id="menu" class="menu">
    
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/">Home</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/post/">Archives</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/tags/">Tags</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/categories/">Categories</a>
          

        

      </li>
    
        <li class="menu-item">
        
          
          
            <a class="menu-item-link" href="https://blog.xiufuguo.com/about/">About</a>
          

        

      </li>
    

    
    

    
  </ul>
</nav>

  </header>

  <div id="mobile-panel">
    <main id="main" class="main bg-llight">
      <div class="content-wrapper">
        <div id="content" class="content container">
          <article class="post bg-white">
    
    <header class="post-header">
      <h1 class="post-title">Thread</h1>
      
      <div class="post-meta">
        <time datetime="2020-06-26" class="post-time">
          2020-06-26
        </time>
        <div class="post-category">
            <a href="https://blog.xiufuguo.com/categories/linux/"> linux </a>
            
          </div>
        <span class="more-meta"> 20412 words </span>
          <span class="more-meta"> 41 min read </span>

        
        

        
        
      </div>
    </header>

    
    
<div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Table of Contents</h2>
  <div class="post-toc-content">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#1-线程的基本概念">1. 线程的基本概念</a>
      <ul>
        <li><a href="#一个进程至少有一个线程">一个进程至少有一个线程</a></li>
        <li><a href="#主线程退出支线程也将退出吗">主线程退出，支线程也将退出吗？</a></li>
        <li><a href="#某个线程崩溃会导致进程退出吗">某个线程崩溃，会导致进程退出吗？</a></li>
      </ul>
    </li>
    <li><a href="#2-线程基本操作">2. 线程基本操作</a>
      <ul>
        <li><a href="#线程的创建">线程的创建</a></li>
        <li><a href="#线程-id">线程 ID</a></li>
        <li><a href="#利用-pstack-命令排查-linux-进程-cpu-使用率过高的问题">利用 PSTACK 命令排查 LINUX 进程 CPU 使用率过高的问题</a></li>
        <li><a href="#等待线程结束">等待线程结束</a></li>
      </ul>
    </li>
    <li><a href="#3-整型变量的原子操作">3. 整型变量的原子操作</a>
      <ul>
        <li><a href="#为什么整型变量赋值操作不是原子的">为什么整型变量赋值操作不是原子的</a></li>
      </ul>
    </li>
    <li><a href="#4-linux-线程资源同步对象">4. Linux 线程资源同步对象</a>
      <ul>
        <li><a href="#linux-互斥体">LINUX 互斥体</a></li>
        <li><a href="#pthread_mutex_normal普通锁">PTHREAD_MUTEX_NORMAL（普通锁）</a></li>
        <li><a href="#pthread_mutex_errorcheck检错锁">PTHREAD_MUTEX_ERRORCHECK（检错锁）</a></li>
        <li><a href="#pthread_mutex_recursive嵌套锁">PTHREAD_MUTEX_RECURSIVE（嵌套锁）</a></li>
        <li><a href="#linux-的信号量">LINUX 的信号量</a></li>
        <li><a href="#linux-条件变量">LINUX 条件变量</a></li>
        <li><a href="#linux-读写锁">LINUX 读写锁</a></li>
      </ul>
    </li>
    <li><a href="#5-如何确保创建的线程一定运行起来">5. 如何确保创建的线程一定运行起来？</a></li>
    <li><a href="#6-锁使用实践经验总结">6. 锁使用实践经验总结</a>
      <ul>
        <li><a href="#减少锁的使用">减少锁的使用</a></li>
        <li><a href="#明确锁的范围">明确锁的范围</a></li>
        <li><a href="#减少锁的粒度">减少锁的粒度</a></li>
        <li><a href="#避免死锁的一些建议">避免死锁的一些建议</a></li>
        <li><a href="#避免活锁的一些建议">避免活锁的一些建议</a></li>
      </ul>
    </li>
    <li><a href="#7-线程局部存储">7. 线程局部存储</a></li>
  </ul>
</nav>
  </div>
</div>

    
    <div class="post-content">
      <h2 id="1-线程的基本概念">1. 线程的基本概念</h2>
<p>线程英文单词是 <strong>thread</strong>。</p>
<p>说到线程不得不提到”<strong>进程</strong>”，一个进程代表计算机中实际跑起来的一个程序，在现代操作系统的保护模式下，每个进程拥有自己独立的进程地址空间和上下文堆栈。但是就一个程序本身执行的操作来说，进程其实什么也不做（不执行任何进程代码），它只是提供一个大环境容器，在进程中实际的执行体是”线程”。</p>
<h3 id="一个进程至少有一个线程">一个进程至少有一个线程</h3>
<hr>
<p>上文也说了，线程是进程中实际干活的单位，因此一个进程至少得有一个线程，我们把这个线称之为”<strong>主线程</strong>”，也就是说，<strong>一个进程至少要有一个主线程</strong>。</p>
<h3 id="主线程退出支线程也将退出吗">主线程退出，支线程也将退出吗？</h3>
<hr>
<p>在 Linux 系统中，如果主线程退出，工作线程一般不会受到影响，还会继续运行下去，但是此时这个进程就会变成所谓的**僵尸进程，**这是一种不好的做法，实际开发中应该避免产生僵尸进程。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="c1">### ps -ef 命令查看系统进程列表时，带有&lt;defunct&gt;字样的进程即僵尸进程</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ps -ef</span>
UID        PID  PPID  C STIME TTY          TIME CMD
root         <span class="m">2</span>     <span class="m">0</span>  <span class="m">0</span> Jan18 ?        00:00:01 <span class="o">[</span>kthreadd<span class="o">]</span>
root         <span class="m">3</span>     <span class="m">2</span>  <span class="m">0</span> Jan18 ?        00:00:25 <span class="o">[</span>ksoftirqd/0<span class="o">]</span>
root         <span class="m">5</span>     <span class="m">2</span>  <span class="m">0</span> Jan18 ?        00:00:00 <span class="o">[</span>kworker/0:0H<span class="o">]</span>
root     <span class="m">60928</span>     <span class="m">1</span>  <span class="m">0</span> 14:48 pts/1    00:00:00 <span class="o">[</span>linuxtid<span class="o">]</span> &lt;defunct&gt;
</code></pre></td></tr></table>
</div>
</div><h3 id="某个线程崩溃会导致进程退出吗">某个线程崩溃，会导致进程退出吗？</h3>
<hr>
<p>这是一个常见的面试题，还有一种问法是：<strong>进程中某个线程崩溃，是否会对其他线程造成影响？</strong></p>
<p>一般来说，每个线程都是独立执行的单位，每个线程都有自己的上下文堆栈，一个线程的的崩溃不会对其他线程造成影响。但是通常情况下，一个线程崩溃会产生一个进程内的错误，例如在 Linux 操作系统中，可能会产生一个 <strong>Segment Fault</strong> 错误，这个错误会产生一个信号，操作系统默认对这个信号的处理就是结束进程，整个进程都被销毁了，这样的话这个进程中存在的其他线程自然也就不存在了。</p>
<h2 id="2-线程基本操作">2. 线程基本操作</h2>
<h3 id="线程的创建">线程的创建</h3>
<hr>
<p>在使用线程之前，我们首先要学会如何创建一个新的线程。不管是哪个库還是哪個高級語言（如 Java），线程的创建最终还是调用操作系统的 <strong>API</strong> 来进行的。</p>
<h4 id="linux线程创建">Linux线程创建</h4>
<hr>
<p>Linux平台上使用 <strong>pthread_create</strong> 這個 <strong>API</strong> 来创建线程，其函数签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_create</span><span class="p">(</span><span class="n">pthread_t</span> <span class="o">*</span><span class="kr">thread</span><span class="p">,</span>
									 <span class="k">const</span> <span class="n">pthread_attr_t</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
									 <span class="kt">void</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="n">start_routine</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span>
									 <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>
<p>参数 <strong>thread</strong>，是一个输入参数，如果线程创建成功，通过这个参数可以得到创建成功的线程 ID（下文会介绍线程ID的知识）。</p>
</li>
<li>
<p>参数 <strong>attr</strong> 指定了该线程的属性，一般设置为 NULL，表示使用默认属性。</p>
</li>
<li>
<p>参数 <strong>start_routine</strong> 指定了线程函数，这里需要注意的是这个函数的调用方式必须是 <strong>__cdecl</strong> 调用，即 <strong>C</strong> <strong>Decl</strong>aration 的缩写，这是 C/C++ 中定义函数时默认的调用方式，一般很少有人注意到这一点。</p>
<p>也就是说，如下函数的调用方式是等价的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//代码片段1： 不显式指定函数调用方式，其调用方式为默认的__cdecl
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">start_routine</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">//代码片段2： 显式指定函数调用方式为默认的__cdecl，等价于代码片段1
</span><span class="c1"></span><span class="kt">void</span> <span class="kr">__cdecl</span> <span class="nf">start_routine</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div></li>
<li>
<p>参数 <strong>arg</strong>，通过这一参数可以在创建线程时将某个参数传入线程函数中，由于这是一个 <strong>void</strong>* 类型，可以方便我们最大化地传入任意多的信息给线程函数。</p>
</li>
<li>
<p>返回值：如果成功创建线程，返回 0; 如果创建失败，则返回响应的错误码，常见的错误码有 <strong>EAGAIN</strong>、<strong>EINVAL</strong>、<strong>EPERM</strong>。</p>
</li>
</ul>
<p>下面是一个使用 <strong>pthread_create</strong> 创建线程的简单示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">threadfunc</span> <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// sleep 1s
</span><span class="c1"></span>        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&#34;I am New Thread!</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">threadid</span><span class="p">;</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">threadfunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="c1">// 权宜之计，让主线程不要提前退出
</span><span class="c1"></span>    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="python-thread">Python Thread</h4>
<hr>
<p>我們可以看到 Python Source Code（thread_pthread.h），发现也是调用 <strong>pthread_create</strong> API 实现。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">long</span>
<span class="nf">PyThread_start_new_thread</span><span class="p">(</span><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">func</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">),</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">...</span>
    <span class="n">status</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">th</span><span class="p">,</span>
<span class="cp">#if defined(THREAD_STACK_SIZE) || defined(PTHREAD_SYSTEM_SCHED_SUPPORTED)
</span><span class="cp"></span>                         <span class="o">&amp;</span><span class="n">attrs</span><span class="p">,</span>
<span class="cp">#else
</span><span class="cp"></span>                         <span class="p">(</span><span class="n">pthread_attr_t</span><span class="o">*</span><span class="p">)</span><span class="nb">NULL</span><span class="p">,</span>
<span class="cp">#endif
</span><span class="cp"></span>                         <span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))</span><span class="n">func</span><span class="p">,</span>
                         <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span>
                         <span class="p">);</span>

<span class="cp">#if defined(THREAD_STACK_SIZE) || defined(PTHREAD_SYSTEM_SCHED_SUPPORTED)
</span><span class="cp"></span>    <span class="n">pthread_attr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attrs</span><span class="p">);</span>
<span class="cp">#endif
</span><span class="cp"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">pthread_detach</span><span class="p">(</span><span class="n">th</span><span class="p">);</span>
<span class="p">...</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="线程-id">线程 ID</h3>
<hr>
<p>一个线程创建成功以后，我们可以拿到一个线程 id，线程 id 是在整个操作系统范围内是唯一的。我们可以使用线程 id 来标识和区分线程，例如我们在日志文件中，我们把打印日志的所在的线程 id 也一起打印出来，这样也方便我们判断和排查问题。创建线程时，上文也介绍了可以通过 <strong>pthread_create</strong> 函数的第一个参数 <strong>thread</strong> （linux平台）得到线程的 id。大多数时候，我们需要在当前调用线程中获取当前线程的 id，在 Linux 平台上可以使用 <strong>pthread_self</strong> 函数获取，这个函数的签名分别如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pthread_t</span> <span class="nf">pthread_self</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="pstack-命令">pstack 命令</h4>
<hr>
<p>Linux 系统中可以通过 <strong>pstack</strong> 命令查看一个进程的线程数量和每个线程的调用堆栈情况。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pstack</span> <span class="n">pid</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>pid</strong> 设置为要查看的进程的 id 即可。以我机器上 nginx 的 worker 进程为例，首先使用 <strong>ps</strong> 命令查看下 nginx 进程id，然后使用 <strong>pstack</strong> 即可查看该进程每个线程的调用堆栈（我这里演示的 nginx 只有一个线程，如果有多个线程，会显示每个线程的调用堆栈）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">root on 127.0.0.1.16clouds.com in ~
$ ps -ef <span class="p">|</span> grep nginx
root      <span class="m">6112</span>     <span class="m">1</span>  <span class="m">0</span> Feb29 ?        00:00:00 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf
root     <span class="m">19971</span> <span class="m">19702</span>  <span class="m">0</span> 03:20 pts/0    00:00:00 grep --color<span class="o">=</span>auto --exclude-dir<span class="o">=</span>.bzr --exclude-dir<span class="o">=</span>CVS --exclude-dir<span class="o">=</span>.git --exclude-dir<span class="o">=</span>.hg --exclude-dir<span class="o">=</span>.svn nginx
root     <span class="m">22255</span>  <span class="m">6112</span>  <span class="m">0</span> May22 ?        00:47:20 nginx: worker process
root on 127.0.0.1.16clouds.com in ~
$ pstack <span class="m">22255</span>
<span class="c1">#0  0x00007f6a4627fe43 in __epoll_wait_nocancel () from /lib64/libc.so.6</span>
<span class="c1">#1  0x000055b2c2f84a23 in ngx_epoll_process_events ()</span>
<span class="c1">#2  0x000055b2c2f7b27a in ngx_process_events_and_timers ()</span>
<span class="c1">#3  0x000055b2c2f82f41 in ngx_worker_process_cycle ()</span>
<span class="c1">#4  0x000055b2c2f813eb in ngx_spawn_process ()</span>
<span class="c1">#5  0x000055b2c2f825f0 in ngx_start_worker_processes ()</span>
<span class="c1">#6  0x000055b2c2f83a20 in ngx_master_process_cycle ()</span>
<span class="c1">#7  0x000055b2c2f5ad0f in main ()</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>注意：<strong>pstack</strong> 命令查看的程序必须携带调试符号，且您所使用的用户必须具有相应的查看权限。</p>
</blockquote>
<h3 id="利用-pstack-命令排查-linux-进程-cpu-使用率过高的问题">利用 PSTACK 命令排查 LINUX 进程 CPU 使用率过高的问题</h3>
<hr>
<p>在实际开发中，我们经常需要去排查和定位一个进程 CPU 占用率过高的问题，如何排查呢？这里可以使用 Linux <strong>top</strong> 和 <strong>pstack</strong> 命令结合使用来排查。我们来看一个具体的例子：</p>
<p>我们使用 top 命令发现我们的机器上有一个叫 qmarket 的进程 CPU 使用率非常高，如下图所示：</p>
<p><img src="http://qbdu2qzd0.bkt.clouddn.com/thread_1.png" alt="avatar"></p>
<p>上图中进程 ID 为 <strong>4427</strong> 的 qmarket 进程占用 CPU 使用率达到 <strong>22.8%</strong>。我们使用 <strong>top -H</strong> 命令再次输出下系统的“进程”列表。</p>
<blockquote>
<p>top 命令的 -H 选项的作用是显示每个一个进程的各个线程运行状态（线程模式）。</p>
</blockquote>
<p>我们来看下执行结果：</p>
<p><img src="http://qbdu2qzd0.bkt.clouddn.com/thread_2.png" alt="avatar"></p>
<p>如上图所示，top 命令第一栏虽然输出还叫 PID，但此时显示的实际是每个线程的线程 ID。我们可以发现 qmarket 程序的线程号为 <strong>4429</strong>、<strong>4430</strong>、<strong>4431</strong>、<strong>4432</strong>、<strong>4433</strong>、<strong>4434</strong>、<strong>4445</strong> 这几个线程占用 CPU 使用率较高。那么这几个线程到底做了什么导致 CPU 使用率高呢？我们使用 <strong>pstack 4427</strong> 来看一下这几个线程（<strong>4427</strong> 是 qmarket 的进程 ID）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@127.0.0.1 ~<span class="o">]</span><span class="c1"># pstack 4427</span>
Thread <span class="m">9</span> <span class="o">(</span>Thread 0x7f315cb39700 <span class="o">(</span>LWP 4428<span class="o">))</span>:
<span class="c1">#0  0x00007f315db3d965 in pthread_cond_wait@@GLIBC_2.3.2 () from /lib64/libpthread.so.0</span>
<span class="c1">#1  0x00007f315d8dc82c in std::condition_variable::wait(std::unique_lock&lt;std::mutex&gt;&amp;) () from /lib64/libstdc++.so.6</span>
<span class="c1">#2  0x0000000000467a89 in CAsyncLog::WriteThreadProc () at ../../sourcebase/utility/AsyncLog.cpp:300</span>
<span class="c1">#3  0x0000000000469a0f in std::_Bind_simple&lt;void (*())()&gt;::_M_invoke&lt;&gt;(std::_Index_tuple&lt;&gt;) (this=0xddeb60) at /usr/include/c++/4.8.2/functional:1732</span>
<span class="c1">#4  0x0000000000469969 in std::_Bind_simple&lt;void (*())()&gt;::operator()() (this=0xddeb60) at /usr/include/c++/4.8.2/functional:1720</span>
<span class="c1">#5  0x0000000000469902 in std:🧵:_Impl&lt;std::_Bind_simple&lt;void (*())()&gt; &gt;::_M_run() (this=0xddeb48) at /usr/include/c++/4.8.2/thread:115</span>
<span class="c1">#6  0x00007f315d8e0070 in ?? () from /lib64/libstdc++.so.6</span>
<span class="c1">#7  0x00007f315db39dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#8  0x00007f315d043ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">8</span> <span class="o">(</span>Thread 0x7f3157fff700 <span class="o">(</span>LWP 4429<span class="o">))</span>:
<span class="c1">#0  0x00007f315d00ae2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007f315d03b704 in usleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x000000000043ed67 in CThread::SleepMs (this=0x7ffc5eed32e0, nMilliseconds=1000) at ../../sourcebase/event/Thread.cpp:106</span>
<span class="c1">#3  0x0000000000441f82 in CEventDispatcher::Run (this=0x7ffc5eed32e0) at ../../sourcebase/event/EventDispatcher.cpp:63</span>
<span class="c1">#4  0x000000000043eb33 in CThread::_ThreadEntry (pParam=0x7ffc5eed32e0) at ../../sourcebase/event/Thread.cpp:26</span>
<span class="c1">#5  0x00007f315db39dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#6  0x00007f315d043ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">7</span> <span class="o">(</span>Thread 0x7f31573fd700 <span class="o">(</span>LWP 4430<span class="o">))</span>:
<span class="c1">#0  0x00007f315d00ae2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007f315d03b704 in usleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x000000000043ed67 in CThread::SleepMs (this=0x7f3150022390, nMilliseconds=1000) at ../../sourcebase/event/Thread.cpp:106</span>
<span class="c1">#3  0x0000000000441f82 in CEventDispatcher::Run (this=0x7f3150022390) at ../../sourcebase/event/EventDispatcher.cpp:63</span>
<span class="c1">#4  0x000000000043eb33 in CThread::_ThreadEntry (pParam=0x7f3150022390) at ../../sourcebase/event/Thread.cpp:26</span>
<span class="c1">#5  0x00007f315db39dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#6  0x00007f315d043ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">6</span> <span class="o">(</span>Thread 0x7f3156bfc700 <span class="o">(</span>LWP 4431<span class="o">))</span>:
<span class="c1">#0  0x00007f315d00ae2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007f315d03b704 in usleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x000000000043ed67 in CThread::SleepMs (this=0x7f3150047890, nMilliseconds=1000) at ../../sourcebase/event/Thread.cpp:106</span>
<span class="c1">#3  0x0000000000441f82 in CEventDispatcher::Run (this=0x7f3150047890) at ../../sourcebase/event/EventDispatcher.cpp:63</span>
<span class="c1">#4  0x000000000043eb33 in CThread::_ThreadEntry (pParam=0x7f3150047890) at ../../sourcebase/event/Thread.cpp:26</span>
<span class="c1">#5  0x00007f315db39dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#6  0x00007f315d043ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">5</span> <span class="o">(</span>Thread 0x7f31563fb700 <span class="o">(</span>LWP 4432<span class="o">))</span>:
<span class="c1">#0  0x00007f315d00ae2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007f315d03b704 in usleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x000000000043ed67 in CThread::SleepMs (this=0x7f3148041fd8, nMilliseconds=1000) at ../../sourcebase/event/Thread.cpp:106</span>
<span class="c1">#3  0x0000000000441f82 in CEventDispatcher::Run (this=0x7f3148041fd8) at ../../sourcebase/event/EventDispatcher.cpp:63</span>
<span class="c1">#4  0x000000000043eb33 in CThread::_ThreadEntry (pParam=0x7f3148041fd8) at ../../sourcebase/event/Thread.cpp:26</span>
<span class="c1">#5  0x00007f315db39dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#6  0x00007f315d043ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">4</span> <span class="o">(</span>Thread 0x7f3155bfa700 <span class="o">(</span>LWP 4433<span class="o">))</span>:
<span class="c1">#0  0x00007f315d00ae2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007f315d03b704 in usleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x000000000043ed67 in CThread::SleepMs (this=0x7f3148052620, nMilliseconds=1000) at ../../sourcebase/event/Thread.cpp:106</span>
<span class="c1">#3  0x0000000000441f82 in CEventDispatcher::Run (this=0x7f3148052620) at ../../sourcebase/event/EventDispatcher.cpp:63</span>
<span class="c1">#4  0x000000000043eb33 in CThread::_ThreadEntry (pParam=0x7f3148052620) at ../../sourcebase/event/Thread.cpp:26</span>
<span class="c1">#5  0x00007f315db39dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#6  0x00007f315d043ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">3</span> <span class="o">(</span>Thread 0x7f31553f9700 <span class="o">(</span>LWP 4434<span class="o">))</span>:
<span class="c1">#0  0x00007f315d00ae2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007f315d03b704 in usleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x000000000043ed67 in CThread::SleepMs (this=0x7f3148062ee0, nMilliseconds=1000) at ../../sourcebase/event/Thread.cpp:106</span>
<span class="c1">#3  0x0000000000441f82 in CEventDispatcher::Run (this=0x7f3148062ee0) at ../../sourcebase/event/EventDispatcher.cpp:63</span>
<span class="c1">#4  0x000000000043eb33 in CThread::_ThreadEntry (pParam=0x7f3148062ee0) at ../../sourcebase/event/Thread.cpp:26</span>
<span class="c1">#5  0x00007f315db39dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#6  0x00007f315d043ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">2</span> <span class="o">(</span>Thread 0x7f3154bf8700 <span class="o">(</span>LWP 4445<span class="o">))</span>:
<span class="c1">#0  0x00007f315d00ae2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007f315d03b704 in usleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x000000000043ed67 in CThread::SleepMs (this=0x7f3150001b00, nMilliseconds=1000) at ../../sourcebase/event/Thread.cpp:106</span>
<span class="c1">#3  0x0000000000441f82 in CEventDispatcher::Run (this=0x7f3150001b00) at ../../sourcebase/event/EventDispatcher.cpp:63</span>
<span class="c1">#4  0x000000000043eb33 in CThread::_ThreadEntry (pParam=0x7f3150001b00) at ../../sourcebase/event/Thread.cpp:26</span>
<span class="c1">#5  0x00007f315db39dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#6  0x00007f315d043ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">1</span> <span class="o">(</span>Thread 0x7f315f2ca3c0 <span class="o">(</span>LWP 4427<span class="o">))</span>:
<span class="c1">#0  0x00007f315db3af47 in pthread_join () from /lib64/libpthread.so.0</span>
<span class="c1">#1  0x000000000043edc7 in CThread::Join (this=0x7ffc5eed32e0) at ../../sourcebase/event/Thread.cpp:130</span>
<span class="c1">#2  0x000000000040cc61 in main (argc=1, argv=0x7ffc5eed3668) at ../../sourceapp/qmarket/qmarket.cpp:309</span>
</code></pre></td></tr></table>
</div>
</div><p>在 pstack 输出的各个线程中，只要逐一对照我们的程序源码来梳理下该线程中是否有大多数时间都处于空转的逻辑，然后修改和优化这些逻辑就可以解决 CPU 使用率过高的问题了，一般情况下，不工作的线程应尽量使用锁对象让其挂起，而不是空转，这样可以提高系统资源利用率。</p>
<h4 id="linux-系统线程-id-的本质">Linux 系统线程 ID 的本质</h4>
<hr>
<p>方法一：</p>
<p>调用 <strong>pthread_create</strong> 函数时，第一个参数在函数调用成功后可以得到线程 ID：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_proc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>方法二：</p>
<p>在需要获取 ID 的线程中调用 <strong>pthread_self()</strong> 函数获取。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">pthread_t</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>
</code></pre></td></tr></table>
</div>
</div><p>方法三：</p>
<p>通过系统调用获取线程 ID</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_gettid</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>方法一</strong>和<strong>方法二</strong>获取的线程 ID 结果是一样的，这是一个 <strong>pthread_t</strong>，输出时本质上是一块内存空间地址。</p>
<p>由于不同的进程可能有同样地址的内存块，因此<strong>方法一</strong>和<strong>方法二</strong>获取的线程 ID 可能不是全系统唯一的，一般是一个很大的数字（内存地址）。而<strong>方法三</strong>获取的线程 ID 是 系统范围内全局唯一的，一般是一个不会太大的整数，这个数字也是就是所谓的 LWP （Light Weight Process，轻量级进程，早期的 Linux 系统的线程是通过进程来实现的，这种线程被称为轻量级线程）的 ID。</p>
<p>我们来看一段具体的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;sys/syscall.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">thread_proc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pthread_t</span><span class="o">*</span> <span class="n">tid1</span> <span class="o">=</span> <span class="p">(</span><span class="n">pthread_t</span><span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tid2</span> <span class="o">=</span> <span class="n">syscall</span><span class="p">(</span><span class="n">SYS_gettid</span><span class="p">);</span>
	<span class="n">pthread_t</span> <span class="n">tid3</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
  <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;tid1: %ld, tid2: %ld, tid3: %ld</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="o">*</span><span class="n">tid1</span><span class="p">,</span> <span class="n">tid2</span><span class="p">,</span> <span class="n">tid3</span><span class="p">);</span>
		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
	<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">thread_proc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tid</span><span class="p">);</span>

	<span class="n">pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码在新开的线程中使用上面介绍的三种方式获取线程 ID，并打印出来，输出结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">tid1: 140185007511296, tid2: 60837, tid3: <span class="m">140185007511296</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>tid2</strong> 即 LWP 的 ID，而 <strong>tid1</strong> 和 <strong>tid3</strong> 是一个内存地址，转换成 16 进制即：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">0x7F7F5D935700
</code></pre></td></tr></table>
</div>
</div><p>这与我们用 pstack 命令看到的线程 ID 是一样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ps -efL | grep linuxtid</span>
root     <span class="m">60712</span> <span class="m">60363</span> <span class="m">60712</span>  <span class="m">0</span>    <span class="m">2</span> 13:25 pts/1    00:00:00 ./linuxtid
root     <span class="m">60712</span> <span class="m">60363</span> <span class="m">60713</span>  <span class="m">0</span>    <span class="m">2</span> 13:25 pts/1    00:00:00 ./linuxtid
root     <span class="m">60720</span> <span class="m">60364</span> <span class="m">60720</span>  <span class="m">0</span>    <span class="m">1</span> 13:25 pts/3    00:00:00 grep --color<span class="o">=</span>auto linuxtid
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># pstack 60712</span>
Thread <span class="m">2</span> <span class="o">(</span>Thread 0x7fd897a50700 <span class="o">(</span>LWP 60713<span class="o">))</span>:
<span class="c1">#0  0x00007fd897b15e2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007fd897b15cc4 in sleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x0000000000400746 in thread_proc (arg=0x7fff390921c8) at linuxtid.cpp:15</span>
<span class="c1">#3  0x00007fd898644dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#4  0x00007fd897b4eead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">1</span> <span class="o">(</span>Thread 0x7fd898a6e740 <span class="o">(</span>LWP 60712<span class="o">))</span>:
<span class="c1">#0  0x00007fd898645f47 in pthread_join () from /lib64/libpthread.so.0</span>
<span class="c1">#1  0x000000000040077e in main () at linuxtid.cpp:25</span>
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># ps -ef | grep linuxtid</span>
root     <span class="m">60838</span> <span class="m">60363</span>  <span class="m">0</span> 14:27 pts/1    00:00:00 ./linuxtid
root     <span class="m">60846</span> <span class="m">60364</span>  <span class="m">0</span> 14:28 pts/3    00:00:00 grep --color<span class="o">=</span>auto linuxtid
<span class="o">[</span>root@localhost ~<span class="o">]</span><span class="c1"># pstack 60838</span>
Thread <span class="m">2</span> <span class="o">(</span>Thread 0x7f7f5d935700 <span class="o">(</span>LWP 60839<span class="o">))</span>:
<span class="c1">#0  0x00007f7f5d9fae2d in nanosleep () from /lib64/libc.so.6</span>
<span class="c1">#1  0x00007f7f5d9facc4 in sleep () from /lib64/libc.so.6</span>
<span class="c1">#2  0x0000000000400746 in thread_proc (arg=0x7fff0523ae68) at linuxtid.cpp:15</span>
<span class="c1">#3  0x00007f7f5e529dd5 in start_thread () from /lib64/libpthread.so.0</span>
<span class="c1">#4  0x00007f7f5da33ead in clone () from /lib64/libc.so.6</span>
Thread <span class="m">1</span> <span class="o">(</span>Thread 0x7f7f5e953740 <span class="o">(</span>LWP 60838<span class="o">))</span>:
<span class="c1">#0  0x00007f7f5e52af47 in pthread_join () from /lib64/libpthread.so.0</span>
<span class="c1">#1  0x000000000040077e in main () at linuxtid.cpp:25</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="等待线程结束">等待线程结束</h3>
<p>实际项目开发中，我们常常会有这样一种需求，即一个线程需要等待另外一个线程执行完任务退出后再继续执行。这在 Linux 操作系统中都提供了相应的操作系统 API，我们来分别介绍一下。</p>
<h4 id="linux-下等待线程结束">Linux 下等待线程结束</h4>
<hr>
<p>Linux 线程库提供了 <strong>pthread_join</strong> 函数，用来等待某线程的退出并接收它的返回值。这种操作被称为<strong>连接</strong>（joining），<strong>pthread_join</strong> 函数签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_join</span><span class="p">(</span><span class="n">pthread_t</span> <span class="kr">thread</span><span class="p">,</span> <span class="kt">void</span><span class="o">**</span> <span class="n">retval</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>参数 <strong>thread</strong>，需要等待的线程 id。</li>
<li>参数 <strong>retval</strong>，输出参数，用于接收等待退出的线程的退出码（<strong>Exit Code</strong>），线程退出码可以通过调用 <strong>pthread_exit</strong> 退出线程时指定，也可以在线程函数中通过 <strong>return</strong> 语句返回。</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">pthread_exit</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">value_ptr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>参数 <strong>value_ptr</strong> 的值可以在 <strong>pthread_join</strong> 中拿到，没有可以设置为 NULL。</p>
<p><strong>pthread_join 函数等待其他线程退出期间会挂起等待的线程</strong>，被挂起的线程不会消耗宝贵任何CPU时间片。直到目标线程退出后，等待的线程会被唤醒。</p>
<p>我们通过一个实例来演示一下这个函数的使用方法，实例功能如下：</p>
<p>程序启动时，开启一个工作线程，工作线程将当前系统时间写入文件中后退出，主线程等待工作线程退出后，从文件中读取出时间并显示在屏幕上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="cp">#define TIME_FILENAME &#34;time.txt&#34;
</span><span class="cp"></span>
<span class="kt">void</span><span class="o">*</span> <span class="nf">fileThreadFunc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">time_t</span> <span class="n">now</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">tm</span><span class="o">*</span> <span class="n">t</span> <span class="o">=</span> <span class="n">localtime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
  <span class="kt">char</span> <span class="n">timeStr</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">timeStr</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="s">&#34;%04d/%02d/%02d %02d:%02d:%02d&#34;</span><span class="p">,</span>
			 <span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_year</span><span class="o">+</span><span class="mi">1900</span><span class="p">,</span>
			 <span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_mon</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
			 <span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_mday</span><span class="p">,</span>
			 <span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_hour</span><span class="p">,</span>
			 <span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_min</span><span class="p">,</span>
			 <span class="n">t</span><span class="o">-&gt;</span><span class="n">tm_sec</span><span class="p">);</span>
	<span class="c1">//文件不存在，则创建；存在，则覆盖。
</span><span class="c1"></span>	<span class="n">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">TIME_FILENAME</span><span class="p">,</span> <span class="s">&#34;w&#34;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
  <span class="p">{</span>
	  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Failed to create time.txt.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

  <span class="n">size_t</span> <span class="n">sizeToWrite</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">timeStr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">size_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">fwrite</span><span class="p">(</span><span class="n">timeStr</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sizeToWrite</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">sizeToWrite</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Write file error.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">pthread_t</span> <span class="n">fileThreadID</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fileThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">fileThreadFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;Failed to create fileThread.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

  <span class="kt">int</span><span class="o">*</span> <span class="n">retval</span><span class="p">;</span>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">fileThreadID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retval</span><span class="p">);</span>

	<span class="c1">//使用r选项，要求文件必须存在
</span><span class="c1"></span>	<span class="n">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">TIME_FILENAME</span><span class="p">,</span> <span class="s">&#34;r&#34;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
	    <span class="n">printf</span><span class="p">(</span><span class="s">&#34;open file error.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	    <span class="k">return</span> <span class="o">-</span><span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">32</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">sizeRead</span> <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="n">fp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sizeRead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
	  <span class="n">printf</span><span class="p">(</span><span class="s">&#34;read file error.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	  <span class="k">return</span> <span class="o">-</span><span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Current Time is: %s.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>程序执行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost threadtest<span class="o">]</span><span class="c1"># ./test</span>
Current Time is: 2018/09/24 21:06:01.
</code></pre></td></tr></table>
</div>
</div><h2 id="3-整型变量的原子操作">3. 整型变量的原子操作</h2>
<h3 id="为什么整型变量赋值操作不是原子的">为什么整型变量赋值操作不是原子的</h3>
<hr>
<p>那么为什么整型变量的操作不是原子性的呢？常见的整型变量操作有如下几种情况：</p>
<ul>
<li>给整型变量赋值一个确定的值，如</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>这条指令操作一般是原子的，因为对应着一条计算机指令，CPU 将立即数 1 搬运到变量 <strong>a</strong> 的内存地址中即可，汇编指令如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="mi">2</span>
</code></pre></td></tr></table>
</div>
</div><p>然后这确是最不常见的情形，由于现代编译器一般存在优化策略，如果变量 <strong>a</strong> 的值在编译期间就可以计算出来（例如这里的例子中 <strong>a</strong> 的值就是<strong>1</strong>），那么 <strong>a</strong> 这个变量本身在正式版本的软件中（release版）就很有可能被编译器优化掉，凡是使用 <strong>a</strong> 的地方，直接使用常量 <strong>1</strong> 来代替。所以实际的执行指令中，这样的指令存在的可能性比较低。</p>
<ul>
<li>变量自身增加或者减去一个值，如</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">a</span><span class="o">++</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>从 C/C++ 语法的级别来看，这是一条语句，是原子的；但是从实际执行的二进制指令来看，也不是原子的，其一般对应三条指令，首先将变量 <strong>a</strong> 对应的内存值搬运到某个寄存器（如 <strong>eax</strong> ）中，然后将该寄存器中的值自增 <strong>1</strong>，再将该寄存器中的值搬运回 <strong>a</strong> 代表的内存中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="n">inc</span> <span class="n">eax</span>
<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">eax</span>
</code></pre></td></tr></table>
</div>
</div><p>现在假设 <strong>a</strong> 的值是0，有两个线程，每个线程对变量 <strong>a</strong> 的值递增 <strong>1</strong>，我们预想的结果应该是 <strong>2</strong>，可实际运行的结果可能是 <strong>1</strong>！是不是很奇怪？分析如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="c1">//线程1
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">thread_func1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">a</span> <span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//线程2
</span><span class="c1"></span><span class="kt">void</span> <span class="nf">thread_func2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">a</span> <span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="http://qbdu2qzd0.bkt.clouddn.com/thread_3.png" alt="avatar"></p>
<p>我们预想的结果是<strong>线程 1</strong> 和<strong>线程 2</strong> 的三条指令各自执行，<em><em>最终 *<em>a</em></em> 的值变为 <strong>2</strong>，但是由于操作系统线程调度的不确定性，<strong>线程 1</strong> 执行完指令①和②后，<strong>eax</strong> 寄存器中的值变为 <strong>1</strong>，此时操作系统切换到 <strong>线程2</strong> 执行，执行指令③④⑤，此时 <strong>eax</strong> 的值变为</em><em>1</em>*；接着操作系统切回**线程 1 **继续执行，执行指令⑦，得到 *****a** 的最终结果 **1**。</p>
<ul>
<li>把一个变量的值赋值给另外一个变量，或者把一个表达式的值赋值给另外一个变量，如</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>从 C/C++ 语法的级别来看，这是也是一条语句，是原子的；但是从实际执行的二进制指令来看，由于现代计算机CPU架构体系的限制，数据不可以直接从内存搬运到另外一块内存，必须借助寄存器中断，这条语句一般对应两条计算机指令，即将变量 <strong>b</strong> 的值搬运到某个寄存器（如<strong>eax</strong>）中，再从该寄存器搬运到变量 <strong>a</strong> 的内存地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">mov</span> <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">b</span><span class="p">]</span>
<span class="n">mov</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">eax</span>
</code></pre></td></tr></table>
</div>
</div><p>既然是两条指令，那么多个线程在执行这两条指令时，某个线程可能会在第一条指令执行完毕后被剥夺 CPU 时间片，切换到另外一个线程而产生不确定的情况。这和上一种情况类似，就不再详细分析了。</p>
<p>说点题外话，网上很多人强调某些特殊的整型数值类型（如 bool 类型）的操作是原子的，这是由于，某些 CPU 生产商开始有意识地从硬件平台保证这一类操作的原子性，但这并不是每一种类型的 CPU 架构都支持，在这一事实成为标准之前，我们在多线程操作整型时还是老老实实使用下文介绍的原子操作或线程同步技术来对这些数据类型进行保护。</p>
<h2 id="4-linux-线程资源同步对象">4. Linux 线程资源同步对象</h2>
<h3 id="linux-互斥体">LINUX 互斥体</h3>
<hr>
<p>Linux 互斥体的用法，一般是通过限制多个线程同时执行某段代码来达到保护资源的目的。和接下来要介绍的信号量、条件变量一样，Linux 互斥体都实现在 NPTL （Native POSIX Thread Library）。在 NPTL 中我们使用数据结构 <strong>pthread_mutex_t</strong> 来表示一个互斥体对象（定义于 <strong>pthread.h</strong> 头文件中）。互斥体对象我们可以使用两种方式来初始化：</p>
<ul>
<li>使用 <strong>PTHREAD_MUTEX_INITIALIZER</strong> 直接给互斥体变量赋值</li>
</ul>
<p>示例代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="n">pthread_mutex_t</span> <span class="n">mymutex</span> <span class="o">=</span> <span class="n">PTHREAD_MUTEX_INITIALIZER</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>使用 <strong>pthread_mutex_init</strong> 函数初始化</li>
</ul>
<p>如果互斥量是动态分配的或者需要给互斥量设置属性，则需要使用 <strong>pthread_mutex_init</strong> 函数来初始化互斥体，这个函数的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_mutex_init</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">mutex</span><span class="p">,</span>
					   <span class="k">const</span> <span class="n">pthread_mutexattr_t</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">attr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>参数 <strong>mutex</strong> 即我们需要初始化的 mutex 对象的指针，参数 <strong>attr</strong> 是需要设置的互斥体属性，通常情况下，我们使用默认属性可以将这个参数设置为 NULL，后面我们会详细介绍每一种属性的用法。 <strong>pthread_mutex_init</strong> 代码示例如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">pthread_mutex_t</span> <span class="n">mymutex</span><span class="p">;</span>
<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>当我们不再需要一个互斥体对象时，可以使用 <strong>pthread_mutex_destroy</strong> 函数来销毁它， <strong>pthread_mutex_destroy</strong> 函数的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_mutex_destroy</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="n">mutex</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>参数 <strong>mutex</strong> 即我们需要销毁的互斥体对象，如果函数执行成功会返回 0，如果执行失败会返回一个错误码表面出错原因。这里我们需要注意两点：</p>
<ul>
<li><strong>使用 PTHREAD_MUTEX_INITIALIZER 初始化的互斥量无须销毁</strong>；</li>
<li><strong>不要去销毁一个已经加锁或正在被条件变量使用的互斥体对象</strong>，当互斥量处于已加锁的状态或者正在和条件变量配合使用时，调用 pthread_mutex_destroy 函数会返回 EBUSY 错误码。当然，这不是绝对的，不同的 Linux 操作系统对这个函数的实现可能不同，因此其行为和返回结果可能也不一样。笔者在 CentOS 7.0 和 Ubuntu 18.10 上测试下面的代码，结果不一样：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_mutex_t</span> <span class="n">mymutex</span><span class="p">;</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EBUSY</span><span class="p">)</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;EBUSY</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Failed to destroy mutex.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Succeed to destroy mutex.</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><blockquote>
<p>由于不同操作系统，对 mutex 对象相关函数的行为结果表现不同，在实际开发中，如果我们遵循一定的使用规范（如创建 mutex 对象后，再对其加锁，加锁后才对其进行解锁操作，解锁后才销毁），那么编码时我们一般不用考虑 <strong>pthread_mutex_init</strong>/<strong>pthread_mutex_destroy</strong>/<strong>pthread_mutex_lock</strong>/<strong>pthread_mutex_unlock</strong> 等函数的返回值。</p>
</blockquote>
<p>对于互斥体的加锁和解锁操作我们一般使用以下三个函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_trylock</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutex_unlock</span><span class="p">(</span><span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="n">mutex</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>参数 <strong>mutex</strong> 设置为我们需要加锁和解锁的互斥体对象，上述函数执行成功返回 0，如果执行失败则返回一个错误码表示具体的出错原因。具体错误码，随互斥体对象的属性类型的不同而不同。</p>
<p>设置互斥体对象的属性需要创建一个 pthread_mutexattr_t 类型的对象，和互斥体对象一样，需要使用 pthread_mutexattr_init 函数初始化之，当不需要这个属性对象时，记得使用 pthread_mutexattr_destroy 去销毁它，这两个函数的签名如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_mutexattr_init</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutexattr_destroy</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>使用 <strong>pthread_mutexattr_settype</strong>/<strong>pthread_mutexattr_gettype</strong> 设置或获取你想要的属性类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_mutexattr_settype</span><span class="p">(</span><span class="n">pthread_mutexattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_mutexattr_gettype</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_mutexattr_t</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">attr</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">type</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>属性类型一般有如下取值：</p>
<h3 id="pthread_mutex_normal普通锁">PTHREAD_MUTEX_NORMAL（普通锁）</h3>
<hr>
<p>这是互斥体对象的默认属性（即上文中介绍的 <strong>pthread_mutex_init</strong> 第二个函数设置为 NULL）。当一个线程对一个普通锁加锁以后，其他线程会阻塞在 <strong>pthread_mutex_lock</strong> 调用处， 直到对互斥体加锁的线程释放了锁，我们来用一段实例代码来验证一下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">pthread_mutex_t</span> <span class="n">mymutex</span><span class="p">;</span>
<span class="kt">int</span>             <span class="n">resourceNo</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">worker_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pthread_t</span> <span class="n">threadID</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;thread start, ThreadID: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">threadID</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Mutex lock, resourceNo: %d, ThreadID: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">resourceNo</span><span class="p">,</span> <span class="n">threadID</span><span class="p">);</span>
		<span class="n">resourceNo</span><span class="o">++</span><span class="p">;</span>

		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;Mutex unlock, resourceNo: %d, ThreadID: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">resourceNo</span><span class="p">,</span> <span class="n">threadID</span><span class="p">);</span>

		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

		<span class="c1">//休眠1秒
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_mutexattr_t</span> <span class="n">mutex_attr</span><span class="p">;</span>
	<span class="n">pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>
	<span class="n">pthread_mutexattr_settype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">,</span> <span class="n">PTHREAD_MUTEX_NORMAL</span><span class="p">);</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>

	<span class="c1">//创建5个工作线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">threadID</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">worker_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">threadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">pthread_mutexattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码创建了五个工作线程，由于使用了互斥体保护资源 <strong>resourceNo</strong>，所以每次在 <strong>pthread_mutex_lock</strong> 与 <strong>pthread_mutex_unlock</strong> 之间的输出都是连续的，一个线程必须完成了这个工作，其他线程才有机会获得执行这段代码的机会，当一个线程拿到锁后，其他线程会阻塞在 <strong>pthread_mutex_lock</strong> 处。</p>
<p>程序执行结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># ./test</span>
thread start, ThreadID: <span class="m">520349440</span>
Mutex lock, resourceNo: 0, ThreadID: <span class="m">520349440</span>
Mutex unlock, resourceNo: 1, ThreadID: <span class="m">520349440</span>
thread start, ThreadID: <span class="m">545527552</span>
Mutex lock, resourceNo: 1, ThreadID: <span class="m">545527552</span>
Mutex unlock, resourceNo: 2, ThreadID: <span class="m">545527552</span>
thread start, ThreadID: <span class="m">511956736</span>
Mutex lock, resourceNo: 2, ThreadID: <span class="m">511956736</span>
Mutex unlock, resourceNo: 3, ThreadID: <span class="m">511956736</span>
thread start, ThreadID: <span class="m">537134848</span>
Mutex lock, resourceNo: 3, ThreadID: <span class="m">537134848</span>
Mutex unlock, resourceNo: 4, ThreadID: <span class="m">537134848</span>
thread start, ThreadID: <span class="m">528742144</span>
Mutex lock, resourceNo: 4, ThreadID: <span class="m">528742144</span>
Mutex unlock, resourceNo: 5, ThreadID: <span class="m">528742144</span>
Mutex lock, resourceNo: 5, ThreadID: <span class="m">545527552</span>
Mutex unlock, resourceNo: 6, ThreadID: <span class="m">545527552</span>
Mutex lock, resourceNo: 6, ThreadID: <span class="m">537134848</span>
Mutex unlock, resourceNo: 7, ThreadID: <span class="m">537134848</span>
Mutex lock, resourceNo: 7, ThreadID: <span class="m">528742144</span>
Mutex unlock, resourceNo: 8, ThreadID: <span class="m">528742144</span>
Mutex lock, resourceNo: 8, ThreadID: <span class="m">520349440</span>
Mutex unlock, resourceNo: 9, ThreadID: <span class="m">520349440</span>
Mutex lock, resourceNo: 9, ThreadID: <span class="m">511956736</span>
Mutex unlock, resourceNo: 10, ThreadID: <span class="m">511956736</span>
Mutex lock, resourceNo: 10, ThreadID: <span class="m">545527552</span>
Mutex unlock, resourceNo: 11, ThreadID: <span class="m">545527552</span>
Mutex lock, resourceNo: 11, ThreadID: <span class="m">537134848</span>
Mutex unlock, resourceNo: 12, ThreadID: <span class="m">537134848</span>
Mutex lock, resourceNo: 12, ThreadID: <span class="m">520349440</span>
Mutex unlock, resourceNo: 13, ThreadID: <span class="m">520349440</span>
Mutex lock, resourceNo: 13, ThreadID: <span class="m">528742144</span>
Mutex unlock, resourceNo: 14, ThreadID: <span class="m">528742144</span>
Mutex lock, resourceNo: 14, ThreadID: <span class="m">511956736</span>
Mutex unlock, resourceNo: 15, ThreadID: <span class="m">511956736</span>
Mutex lock, resourceNo: 15, ThreadID: <span class="m">528742144</span>
Mutex unlock, resourceNo: 16, ThreadID: <span class="m">528742144</span>
Mutex lock, resourceNo: 16, ThreadID: <span class="m">545527552</span>
Mutex unlock, resourceNo: 17, ThreadID: <span class="m">545527552</span>
Mutex lock, resourceNo: 17, ThreadID: <span class="m">520349440</span>
Mutex unlock, resourceNo: 18, ThreadID: <span class="m">520349440</span>
Mutex lock, resourceNo: 18, ThreadID: <span class="m">537134848</span>
Mutex unlock, resourceNo: 19, ThreadID: <span class="m">537134848</span>
Mutex lock, resourceNo: 19, ThreadID: <span class="m">511956736</span>
Mutex unlock, resourceNo: 20, ThreadID: <span class="m">511956736</span>
Mutex lock, resourceNo: 20, ThreadID: <span class="m">545527552</span>
Mutex unlock, resourceNo: 21, ThreadID: <span class="m">545527552</span>
Mutex lock, resourceNo: 21, ThreadID: <span class="m">528742144</span>
Mutex unlock, resourceNo: 22, ThreadID: <span class="m">528742144</span>
Mutex lock, resourceNo: 22, ThreadID: <span class="m">520349440</span>
Mutex unlock, resourceNo: 23, ThreadID: <span class="m">520349440</span>
Mutex lock, resourceNo: 23, ThreadID: <span class="m">537134848</span>
Mutex unlock, resourceNo: 24, ThreadID: <span class="m">537134848</span>
Mutex lock, resourceNo: 24, ThreadID: <span class="m">511956736</span>
Mutex unlock, resourceNo: 25, ThreadID: <span class="m">511956736</span>
Mutex lock, resourceNo: 25, ThreadID: <span class="m">528742144</span>
Mutex unlock, resourceNo: 26, ThreadID: <span class="m">528742144</span>
Mutex lock, resourceNo: 26, ThreadID: <span class="m">545527552</span>
Mutex unlock, resourceNo: 27, ThreadID: <span class="m">545527552</span>
Mutex lock, resourceNo: 27, ThreadID: <span class="m">520349440</span>
Mutex unlock, resourceNo: 28, ThreadID: <span class="m">520349440</span>
Mutex lock, resourceNo: 28, ThreadID: <span class="m">511956736</span>
Mutex unlock, resourceNo: 29, ThreadID: <span class="m">511956736</span>
Mutex lock, resourceNo: 29, ThreadID: <span class="m">537134848</span>
Mutex unlock, resourceNo: 30, ThreadID: <span class="m">537134848</span>
</code></pre></td></tr></table>
</div>
</div><p>一个线程如果对一个已经加锁的普通锁再次使用 pthread_mutex_lock 加锁，程序会阻塞在第二次调用 pthread_mutex_lock 代码处。测试代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_mutex_t</span> <span class="n">mymutex</span><span class="p">;</span>
	<span class="n">pthread_mutexattr_t</span> <span class="n">mutex_attr</span><span class="p">;</span>
	<span class="n">pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>
	<span class="n">pthread_mutexattr_settype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">,</span> <span class="n">PTHREAD_MUTEX_NORMAL</span><span class="p">);</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;ret = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;ret = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">pthread_mutexattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译并使用 gdb 将程序运行起来，程序只输出了一行，我们按 Ctrl + C （下文中 ^C 字符）将 gdb 中断下来，然后使用 bt 命令发现程序确实阻塞在第二个 <strong>pthread_mutex_lock</strong> 函数调用处：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># g++ -g -o test test.cpp -lpthread</span>
<span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># gdb test</span>
Reading symbols from /root/testmultithread/test...done.
<span class="o">(</span>gdb<span class="o">)</span> r
Starting program: /root/testmultithread/test
<span class="o">[</span>Thread debugging using libthread_db enabled<span class="o">]</span>
Using host libthread_db library <span class="s2">&#34;/lib64/libthread_db.so.1&#34;</span>.
<span class="nv">ret</span> <span class="o">=</span> <span class="m">0</span>
^C
Program received signal SIGINT, Interrupt.
0x00007ffff7bcd4ed in __lll_lock_wait <span class="o">()</span> from /lib64/libpthread.so.0
Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64
<span class="o">(</span>gdb<span class="o">)</span> bt
<span class="c1">#0  0x00007ffff7bcd4ed in __lll_lock_wait () from /lib64/libpthread.so.0</span>
<span class="c1">#1  0x00007ffff7bc8dcb in _L_lock_883 () from /lib64/libpthread.so.0</span>
<span class="c1">#2  0x00007ffff7bc8c98 in pthread_mutex_lock () from /lib64/libpthread.so.0</span>
<span class="c1">#3  0x00000000004007f4 in main () at ConsoleApplication10.cpp:17</span>
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>在这种类型的情况， <strong>pthread_mutex_trylock</strong> 函数如果拿不到锁，不会阻塞，函数会立即返回，并返回 <strong>EBUSY</strong> 错误码。</p>
<h3 id="pthread_mutex_errorcheck检错锁">PTHREAD_MUTEX_ERRORCHECK（检错锁）</h3>
<hr>
<p>如果一个线程使用 <strong>pthread_mutex_lock</strong> 对已经加锁的互斥体对象再次加锁，<strong>pthread_mutex_lock</strong> 会返回 <strong>EDEADLK</strong>。</p>
<p>我们验证一下线程对自己已经加锁的互斥体对象再次加锁是什么行为？</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_mutex_t</span> <span class="n">mymutex</span><span class="p">;</span>
	<span class="n">pthread_mutexattr_t</span> <span class="n">mutex_attr</span><span class="p">;</span>
	<span class="n">pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>
	<span class="n">pthread_mutexattr_settype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">,</span> <span class="n">PTHREAD_MUTEX_ERRORCHECK</span><span class="p">);</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;ret = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;ret = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">EDEADLK</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">&#34;EDEADLK</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">pthread_mutexattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译并运行程序，程序输出结果确实如上面所说：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># g++ -g -o test11 test.cpp -lpthread</span>
<span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># ./test11</span>
<span class="nv">ret</span> <span class="o">=</span> <span class="m">0</span>
<span class="nv">ret</span> <span class="o">=</span> <span class="m">35</span>
EDEADLK
</code></pre></td></tr></table>
</div>
</div><p>再来看一下，一个线程加锁，其他线程再次加锁的效果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">pthread_mutex_t</span> <span class="n">mymutex</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">worker_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pthread_t</span> <span class="n">threadID</span> <span class="o">=</span> <span class="n">pthread_self</span><span class="p">();</span>

	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;thread start, ThreadID: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">threadID</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="n">EDEADLK</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;EDEADLK, ThreadID: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">threadID</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">else</span>
			<span class="n">printf</span><span class="p">(</span><span class="s">&#34;ret = %d, ThreadID: %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">threadID</span><span class="p">);</span>

		<span class="c1">//休眠1秒
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_mutexattr_t</span> <span class="n">mutex_attr</span><span class="p">;</span>
	<span class="n">pthread_mutexattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>
	<span class="n">pthread_mutexattr_settype</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">,</span> <span class="n">PTHREAD_MUTEX_ERRORCHECK</span><span class="p">);</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>

	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">printf</span><span class="p">(</span><span class="s">&#34;ret = %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="c1">//创建5个工作线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">threadID</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">threadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">worker_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">threadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
	<span class="n">pthread_mutexattr_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex_attr</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译程序，然后使用 gdb 运行起来，发现程序并没有有任何输出，按 Ctrl + C 中断下来，输入 <strong>info thread</strong> 命令发现工作线程均阻塞在 <strong>pthread_mutex_lock</strong> 函数调用处。操作及输出结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># g++ -g -o test8 ConsoleApplication8.cpp -lpthread</span>
<span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># ./test8</span>
<span class="nv">ret</span> <span class="o">=</span> <span class="m">0</span>
thread start, ThreadID: -1821989120
thread start, ThreadID: -1830381824
thread start, ThreadID: -1838774528
thread start, ThreadID: -1847167232
thread start, ThreadID: -1813596416
^C
<span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># gdb test8</span>
GNU gdb <span class="o">(</span>GDB<span class="o">)</span> Red Hat Enterprise Linux 7.6.1-114.el7
Copyright <span class="o">(</span>C<span class="o">)</span> <span class="m">2013</span> Free Software Foundation, Inc.
License GPLv3+: GNU GPL version <span class="m">3</span> or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type <span class="s2">&#34;show copying&#34;</span>
and <span class="s2">&#34;show warranty&#34;</span> <span class="k">for</span> details.
This GDB was configured as <span class="s2">&#34;x86_64-redhat-linux-gnu&#34;</span>.
For bug reporting instructions, please see:
&lt;http://www.gnu.org/software/gdb/bugs/&gt;...
Reading symbols from /root/testmultithread/test8...done.
<span class="o">(</span>gdb<span class="o">)</span> r
Starting program: /root/testmultithread/test8
<span class="o">[</span>Thread debugging using libthread_db enabled<span class="o">]</span>
Using host libthread_db library <span class="s2">&#34;/lib64/libthread_db.so.1&#34;</span>.
<span class="nv">ret</span> <span class="o">=</span> <span class="m">0</span>
<span class="o">[</span>New Thread 0x7ffff6fd2700 <span class="o">(</span>LWP 3276<span class="o">)]</span>
thread start, ThreadID: -151181568
<span class="o">[</span>New Thread 0x7ffff67d1700 <span class="o">(</span>LWP 3277<span class="o">)]</span>
thread start, ThreadID: -159574272
<span class="o">[</span>New Thread 0x7ffff5fd0700 <span class="o">(</span>LWP 3278<span class="o">)]</span>
thread start, ThreadID: -167966976
<span class="o">[</span>New Thread 0x7ffff57cf700 <span class="o">(</span>LWP 3279<span class="o">)]</span>
thread start, ThreadID: -176359680
<span class="o">[</span>New Thread 0x7ffff4fce700 <span class="o">(</span>LWP 3280<span class="o">)]</span>
thread start, ThreadID: -184752384
^C
Program received signal SIGINT, Interrupt.
0x00007ffff7bc7f47 in pthread_join <span class="o">()</span> from /lib64/libpthread.so.0
Missing separate debuginfos, use: debuginfo-install glibc-2.17-260.el7.x86_64 libgcc-4.8.5-36.el7.x86_64 libstdc++-4.8.5-36.el7.x86_64
<span class="o">(</span>gdb<span class="o">)</span> bt
<span class="c1">#0  0x00007ffff7bc7f47 in pthread_join () from /lib64/libpthread.so.0</span>
<span class="c1">#1  0x00000000004009e9 in main () at ConsoleApplication8.cpp:50</span>
<span class="o">(</span>gdb<span class="o">)</span> inf threads
  Id   Target Id         Frame
  <span class="m">6</span>    Thread 0x7ffff4fce700 <span class="o">(</span>LWP 3280<span class="o">)</span> <span class="s2">&#34;test8&#34;</span> 0x00007ffff7bcd4ed in __lll_lock_wait <span class="o">()</span> from /lib64/libpthread.so.0
  <span class="m">5</span>    Thread 0x7ffff57cf700 <span class="o">(</span>LWP 3279<span class="o">)</span> <span class="s2">&#34;test8&#34;</span> 0x00007ffff7bcd4ed in __lll_lock_wait <span class="o">()</span> from /lib64/libpthread.so.0
  <span class="m">4</span>    Thread 0x7ffff5fd0700 <span class="o">(</span>LWP 3278<span class="o">)</span> <span class="s2">&#34;test8&#34;</span> 0x00007ffff7bcd4ed in __lll_lock_wait <span class="o">()</span> from /lib64/libpthread.so.0
  <span class="m">3</span>    Thread 0x7ffff67d1700 <span class="o">(</span>LWP 3277<span class="o">)</span> <span class="s2">&#34;test8&#34;</span> 0x00007ffff7bcd4ed in __lll_lock_wait <span class="o">()</span> from /lib64/libpthread.so.0
  <span class="m">2</span>    Thread 0x7ffff6fd2700 <span class="o">(</span>LWP 3276<span class="o">)</span> <span class="s2">&#34;test8&#34;</span> 0x00007ffff7bcd4ed in __lll_lock_wait <span class="o">()</span> from /lib64/libpthread.so.0
* <span class="m">1</span>    Thread 0x7ffff7fee740 <span class="o">(</span>LWP 3272<span class="o">)</span> <span class="s2">&#34;test8&#34;</span> 0x00007ffff7bc7f47 in pthread_join <span class="o">()</span> from /lib64/libpthread.so.0
<span class="o">(</span>gdb<span class="o">)</span>
</code></pre></td></tr></table>
</div>
</div><p>通过上面的实验，如果互斥体的属性是 <strong>PTHREAD_MUTEX_ERRORCHECK</strong>，当前线程重复调用 <strong>pthread_mutex_lock</strong> 会直接返回 <strong>EDEADLOCK</strong>，其他线程如果对这个互斥体再次调用 <strong>pthread_mutex_lock</strong> 会阻塞在该函数的调用处。</p>
<h3 id="pthread_mutex_recursive嵌套锁">PTHREAD_MUTEX_RECURSIVE（嵌套锁）</h3>
<hr>
<ul>
<li>该属性允许同一个线程对其持有的互斥体重复加锁，每次成功调用 <strong>pthread_mutex_lock</strong> 一次，该互斥体对象的锁引用计数就会增加一次，相反，每次成功调用 <strong>pthread_mutex_unlock</strong> 一次，锁引用计数就会减少一次，当锁引用计数值为 0 时允许其他线程获得该锁，否则其他线程调用 <strong>pthread_mutex_lock</strong> 时尝试获取锁时，会阻塞在那里。这种方式很好理解，这里就不贴示例代码了。</li>
</ul>
<p>我们来总结下 Linux 下的互斥体对象的使用要点：</p>
<ul>
<li>虽然我在上文演示了同一个线程对一个互斥体对象反复进行加锁，但实际开发中，我们需要用到这种场景的情形非常少。</li>
<li>与 Windows 的临界区对象一样，一些有很多出口的逻辑中，为了避免因忘记调用 <strong>pthread_mutex_lock</strong> 出现死锁或者在逻辑出口处有大量解锁的重复代码出现，建议使用 RAII 技术将互斥体对象封装起来，具体方式我在上文中已经介绍过了，这里不再赘述。</li>
</ul>
<h3 id="linux-的信号量">LINUX 的信号量</h3>
<hr>
<p>与 Windows 的 Semaphore 对象使用原理一样，Linux 的信号量本质上也是暗含着“资源有多份，可以同时被多个线程访问”的意味，故信号量的原理这里不再赘述。</p>
<p>Linux 信号量常用的一组 API 函数是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp"></span><span class="kt">int</span> <span class="nf">sem_init</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pshared</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_destroy</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_post</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_wait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_trywait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">sem_timedwait</span><span class="p">(</span><span class="n">sem_t</span><span class="o">*</span> <span class="n">sem</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">abs_timeout</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><ul>
<li>函数 <strong>sem_init</strong> 用于初始化一个信号量，第一个参数 <strong>sem</strong> 传入需要初始化的信号量对象的地址；第二个参数 <strong>pshared</strong> 表示该信号量是否可以被初始化该信号量的进程 fork 出来的子进程共享，取值为 0 （不可以共享），1 （可以共享）；第三个参数 <strong>value</strong> 用于设置信号量初始状态下资源的数量。函数 <strong>sem_init</strong> 函数调用成功返回 0， 失败返回 -1，实际编码中只要我们的写法得当一般不关心该函数的返回值。</li>
<li>函数 <strong>sem_destroy</strong> 用于销毁一个信号量。</li>
<li>函数 <strong>sem_post</strong> 将信号量的资源计数递增 1，并解锁该信号量对象，这样其他由于使用 <strong>sem_wait</strong> 被阻塞的线程会被唤醒。</li>
<li>如果当前信号量资源计数为 0，函数 <strong>sem_wait</strong> 会阻塞调用线程；直到信号量对象的资源计数大于 0 时被唤醒，唤醒后将资源计数递减 1，然后立即返回；函数 <strong>sem_trywait</strong> 是函数 <strong>sem_wait</strong> 的非阻塞版本，如果当前信号量对象的资源计数等于 0，<strong>sem_trywait</strong> 会立即返回不会阻塞调用线程，返回值是 -1，错误码 errno 被设置成 <strong>EAGAIN</strong>；函数 <strong>sem_timedwait</strong> 是带有等待时间的版本，等待时间在第二个参数 <strong>abs_timeout</strong> 中设置，这是个结构体的定义如下：</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">struct</span> <span class="n">timespec</span>
<span class="p">{</span>
	<span class="n">time_t</span> <span class="n">tv_sec</span><span class="p">;</span>      <span class="cm">/* 秒 */</span>
	<span class="kt">long</span>   <span class="n">tv_nsec</span><span class="p">;</span>     <span class="cm">/* 纳秒 [0 .. 999999999] */</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>sem_timedwait</strong> 在参数 <strong>abs_timeout</strong> 设置的时间内等待信号量对象的资源计数大于0，否则超时返回，返回值为 -1，错误码 errno 是 <strong>ETIMEDOUT</strong>。当使用 <strong>sem_timedwait</strong> 时，参数 <strong>abs_timeout</strong> 不能设置为 NULL，否则程序会在运行时调用 <strong>sem_timedwait</strong> 产生崩溃。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>sem_wait、sem_trywait、sem_timedwait 函数将资源计数递减一时会同时锁定信号量对象，因此当资源计数为 1 时，如果有多个线程调用 sem_wait 等函数等待该信号量时，只会有一个线程被唤醒。sem_wait 函数返回时，会释放对该信号量的锁。</li>
<li>sem_wait、sem_trywait、sem_timedwait 函数调用成功后返回值均为 0，调用失败返回 -1，可以通过错误码 errno 获得失败原因。</li>
<li>sem_wait、sem_trywait、sem_timedwait 可以被 Linux 信号中断，被信号中断后，函数立即返回，返回值是 -1，错误码 errno 为EINTR。</li>
</ol>
</blockquote>
<blockquote>
<p>虽然上述函数没有以 pthread_ 作为前缀，实际使用这个系列的函数时需要链接 pthread 库。</p>
</blockquote>
<p>我们看一个信号量的具体使用示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">class</span> <span class="n">Task</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
	<span class="n">Task</span><span class="p">(</span><span class="kt">int</span> <span class="n">taskID</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">taskID</span> <span class="o">=</span> <span class="n">taskID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">doTask</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;handle a task, taskID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">taskID</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, threadID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
	<span class="kt">int</span> <span class="n">taskID</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">pthread_mutex_t</span>  <span class="n">mymutex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">*&gt;</span> <span class="n">tasks</span><span class="p">;</span>
<span class="n">sem_t</span>            <span class="n">mysemaphore</span><span class="p">;</span>


<span class="kt">void</span><span class="o">*</span> <span class="nf">consumer_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Task</span><span class="o">*</span> <span class="n">pTask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysemaphore</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
		<span class="n">pTask</span> <span class="o">=</span> <span class="n">tasks</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">tasks</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>
		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

		<span class="n">pTask</span><span class="o">-&gt;</span><span class="n">doTask</span><span class="p">();</span>
		<span class="n">delete</span> <span class="n">pTask</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">producer_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">taskID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Task</span><span class="o">*</span> <span class="n">pTask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pTask</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Task</span><span class="p">(</span><span class="n">taskID</span><span class="p">);</span>

		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
		<span class="n">tasks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pTask</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;produce a task, taskID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">taskID</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, threadID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

		<span class="c1">//释放信号量，通知消费者线程
</span><span class="c1"></span>		<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysemaphore</span><span class="p">);</span>

		<span class="n">taskID</span> <span class="o">++</span><span class="p">;</span>

		<span class="c1">//休眠1秒
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="c1">//初始信号量资源计数为0
</span><span class="c1"></span>	<span class="n">sem_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysemaphore</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="c1">//创建5个消费者线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">consumerThreadID</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consumerThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consumer_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//创建一个生产者线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">producerThreadID</span><span class="p">;</span>
	<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">producerThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">producer_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">pthread_join</span><span class="p">(</span><span class="n">producerThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">consumerThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sem_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mysemaphore</span><span class="p">);</span>
	<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>以上代码中我们创建一个生产者线程和 5 个消费者线程，初始信号量计数为 0 代表开始没有可执行任务，所以 5 个消费线程均阻塞在 <strong>sem_wait</strong> 调用处，接着生产者每隔 1 秒产生一个任务，然后通过调用 <strong>sem_post</strong> 将信号量资源计数增加一，此时其中一个线程会被唤醒，然后我们从任务队列中取出任务，执行任务，由于任务对象是 new 出来的，我们需要 delete 掉以避免内存泄露。</p>
<p>有人可能会觉得奇怪，在调用 <strong>sem_wait</strong> 和 <strong>sem_post</strong> 时会对信号量对象进行加锁和解锁，为什么这里还需要使用一个 mutex？这个 mutex 是用来保护队列 <strong>tasks</strong> 的，因为多个线程会同时读写之。这个例子类似于银行里多个客户等待柜台有空闲办理取钱业务，每次有空闲的柜台，就可以告诉客户，但是多人同时取钱时，银行的资金总账户增减一定是原子性的。</p>
<p>编译并生成文件 <strong>semaphore</strong> ，然后运行之，输出结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost testsemaphore<span class="o">]</span><span class="c1"># g++ -g -o semaphore semaphore.cpp -lpthread</span>
<span class="o">[</span>root@localhost testsemaphore<span class="o">]</span><span class="c1"># ./semaphore</span>
produce a task, taskID: 0, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 0, threadID: <span class="m">140055277381376</span>
produce a task, taskID: 1, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 1, threadID: <span class="m">140055277381376</span>
produce a task, taskID: 2, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 2, threadID: <span class="m">140055268988672</span>
produce a task, taskID: 3, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 3, threadID: <span class="m">140055294166784</span>
produce a task, taskID: 4, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 4, threadID: <span class="m">140055302559488</span>
produce a task, taskID: 5, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 5, threadID: <span class="m">140055285774080</span>
produce a task, taskID: 6, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 6, threadID: <span class="m">140055277381376</span>
produce a task, taskID: 7, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 7, threadID: <span class="m">140055268988672</span>
produce a task, taskID: 8, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 8, threadID: <span class="m">140055294166784</span>
produce a task, taskID: 9, threadID: <span class="m">140055260595968</span>
handle a task, taskID: 9, threadID: <span class="m">140055302559488</span>
...更多输出结果省略...
</code></pre></td></tr></table>
</div>
</div><h3 id="linux-条件变量">LINUX 条件变量</h3>
<hr>
<p>有人说 Linux 条件变量（Condition Variable）是最不会用错的一种线程同步对象，确实是这样，但这必须建立在你对条件变量熟练使用的基础之上。我们先来讨论一下为什么会存在条件变量这样一种机制。</p>
<h4 id="为什么需要使用条件变量">为什么需要使用条件变量？</h4>
<hr>
<p>实际应用中，我们常常会有类似如下需求：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="c1">//以下是伪码，m的类型是pthread_mutex_t，并且已经初始化过了
</span><span class="c1"></span><span class="kt">int</span> <span class="nf">WaitForTrue</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">condition</span> <span class="n">is</span> <span class="nb">false</span><span class="p">)</span>		<span class="c1">//条件不满足
</span><span class="c1"></span>	<span class="p">{</span>
		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>	<span class="c1">//解锁等待其他线程改变condition
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>					<span class="c1">//睡眠n秒
</span><span class="c1"></span>		<span class="c1">//n秒后再次加锁验证条件是否满足
</span><span class="c1"></span>		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><img src="http://qbdu2qzd0.bkt.clouddn.com/thread_4.png" alt="avatar"></p>
<p>这段逻辑的用途是我们需要反复判断一个多线程共享条件是否满足，一直到该条件满足为止，由于该条件被多个线程操作因此每次判断之前我们都需要进行加锁操作，判断完毕后需要进行解锁操作。但是上述逻辑存在严重的效率问题，假设我们解锁离开临界区后，此时由于其他线程修改了条件导致条件满足了，此时程序仍然需要睡眠 n 秒后才能得到反馈。因此我们需要这样一种机制：</p>
<blockquote>
<p>某个线程 A 在条件不满足的情况下，主动让出互斥量，让其他线程去折腾，线程在此处等待，等待条件的满足；一旦条件满足，线程就可以被立刻唤醒。线程 A 之所以可以安心等待，依赖的是其他线程的协作，它确信会有一个线程在发现条件满足以后，将向它发送信号，并且让出互斥量。如果其他线程不配合（不发信号，不让出互斥量），这个主动让出互斥量并等待事件发生的线程 A 就真的要等到花儿都谢了。</p>
</blockquote>
<p>这个例子解释了为什么需要条件等待，但是条件等待还不是条件变量的全部功能。</p>
<h4 id="条件变量为什么要与互斥体对象结合">条件变量为什么要与互斥体对象结合</h4>
<hr>
<p>很多第一次学习 Linux 条件变量的读者会觉得困惑：为什么条件变量一定要与一个互斥体对象结合使用？我们来看下，假设条件变量不与互斥体对象结合的效果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="mi">1</span> <span class="c1">//m的类型是pthread_mutex_t，并且已经初始化过了，cv是条件变量
</span><span class="c1"></span><span class="mi">2</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">)</span>
<span class="mi">3</span> <span class="k">while</span><span class="p">(</span><span class="n">condition_is_false</span><span class="p">)</span>
<span class="mi">4</span> <span class="p">{</span>
<span class="mi">5</span>     <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="mi">6</span>     <span class="c1">//解锁之后，等待之前，可能条件已经满足，信号已经发出，但是该信号可能会被错过
</span><span class="c1"></span><span class="mi">7</span>     <span class="n">cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cv</span><span class="p">);</span>
<span class="mi">8</span>     <span class="nf">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="p">);</span>
<span class="mi">9</span> <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码中，假设线程 A 执行完第 5 行代码 pthread_mutex_unlock(&amp;m); 后 CPU 时间片被剥夺，此时另外一个线程 B 获得该互斥体对象 m，然后发送条件信号，等线程 A 重新获得时间片后，由于该信号已经被错过了，这样可能会导致线程 A 在 第 7 行 cond_wait(&amp;cv); 无限阻塞下去。</p>
<p>造成这个问题的根源是释放互斥体对象与条件变量等待唤醒不是原子操作，即解锁和等待这两个步骤必须是同一个原子性的操作，以确保 cond_wait 唤醒之前不会有其他线程获得这个互斥体对象。</p>
<h4 id="条件变量的使用">条件变量的使用</h4>
<hr>
<p>介绍了这么多，我们来正式介绍一下条件变量相关的系统 API 的使用方法。</p>
<p>条件变量的初始化和销毁可以使用如下 API 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_cond_init</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span> <span class="n">cond</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_condattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_destroy</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span> <span class="n">cond</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>在 Linux 系统中 <strong>pthread_cond_t</strong> 即是条件变量的类型，当然和前面介绍的互斥体一样，你也可以使用如下方式去初始化一个条件变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pthread_cond_t</span> <span class="n">cond</span> <span class="o">=</span> <span class="n">PTHREAD_COND_INITIALIZER</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>等待条件变量的满足可以使用如下 API 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_cond_wait</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">cond</span><span class="p">,</span> <span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">mutex</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_timedwait</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">cond</span><span class="p">,</span> <span class="n">pthread_mutex_t</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">mutex</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span><span class="o">*</span> <span class="kr">restrict</span> <span class="n">abstime</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>一般情况下如果条件变量代表的条件不会满足，调用 <strong>pthread_cond_wait</strong> 的线程会一直等待下去；<strong>pthread_cond_timedwait</strong> 是 <strong>pthread_cond_wait</strong> 非阻塞版本，它会在指定时间内等待条件满足，超过参数 <strong>abstime</strong> 设置的时候后 <strong>pthread_cond_timedwait</strong> 函数会立即返回。</p>
<blockquote>
<p>注意：对于参数 <strong>abstime</strong>，正如其名字暗示的，这是一个 absolute time（绝对时间），也就是说，如果你打算让函数等待 5 秒，那么你应该先得到当前系统的时间，然后加上 5 秒计算出最终的时间作为参数 <strong>abstime</strong> 的值。</p>
</blockquote>
<p>因调用 <strong>pthread_cond_wait</strong> 等待的线程可以被以下 API 函数唤醒：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_cond_signal</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span> <span class="n">cond</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_cond_broadcast</span><span class="p">(</span><span class="n">pthread_cond_t</span><span class="o">*</span> <span class="n">cond</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>pthread_cond_signal</strong> 一次唤醒一个线程，如果有多个线程调用 <strong>pthread_cond_wait</strong> 等待，具体哪个线程被唤醒是不确定的（可以认为是随机的）；<strong>pthread_cond_broadcast</strong> 可以同时唤醒多个调用 <strong>pthread_cond_wait</strong> 等待的线程。前者相当于发送一次条件通知，后者广播一次条件通知。成功等待到条件信号，<strong>pthread_cond_signal</strong> 和 <strong>pthread_cond_broadcast</strong> 返回 0，反之返回非0值，具体错误原因可以通过错误码 errno 获得。</p>
<p>我们将前文中介绍信号量的示例代码用条件变量来改写下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;errno.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;semaphore.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">class</span> <span class="n">Task</span>
<span class="p">{</span>
<span class="nl">public</span><span class="p">:</span>
	<span class="n">Task</span><span class="p">(</span><span class="kt">int</span> <span class="n">taskID</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">taskID</span> <span class="o">=</span> <span class="n">taskID</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="kt">void</span> <span class="n">doTask</span><span class="p">()</span>
	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;handle a task, taskID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">taskID</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, threadID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">private</span><span class="p">:</span>
	<span class="kt">int</span> <span class="n">taskID</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">pthread_mutex_t</span>  <span class="n">mymutex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">*&gt;</span> <span class="n">tasks</span><span class="p">;</span>
<span class="n">pthread_cond_t</span>   <span class="n">mycv</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">consumer_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">Task</span><span class="o">*</span> <span class="n">pTask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
		<span class="p">{</span>
			<span class="c1">//如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行。
</span><span class="c1"></span>			<span class="c1">//当发生变化后，条件合适，pthread_cond_wait将直接获得锁。
</span><span class="c1"></span>			<span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mycv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">pTask</span> <span class="o">=</span> <span class="n">tasks</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
		<span class="n">tasks</span><span class="p">.</span><span class="n">pop_front</span><span class="p">();</span>

		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pTask</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">pTask</span><span class="o">-&gt;</span><span class="n">doTask</span><span class="p">();</span>
		<span class="n">delete</span> <span class="n">pTask</span><span class="p">;</span>
		<span class="n">pTask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">producer_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">taskID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">Task</span><span class="o">*</span> <span class="n">pTask</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pTask</span> <span class="o">=</span> <span class="n">new</span> <span class="n">Task</span><span class="p">(</span><span class="n">taskID</span><span class="p">);</span>

		<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
		<span class="n">tasks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">pTask</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;produce a task, taskID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">taskID</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, threadID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

		<span class="c1">//释放信号量，通知消费者线程
</span><span class="c1"></span>		<span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mycv</span><span class="p">);</span>

		<span class="n">taskID</span> <span class="o">++</span><span class="p">;</span>

		<span class="c1">//休眠1秒
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mycv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">//创建5个消费者线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">consumerThreadID</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">consumerThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">consumer_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//创建一个生产者线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">producerThreadID</span><span class="p">;</span>
	<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">producerThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">producer_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">pthread_join</span><span class="p">(</span><span class="n">producerThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">consumerThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mycv</span><span class="p">);</span>
	<span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译并执行上述程序，输出结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">testsemaphore</span><span class="p">]</span><span class="err">#</span> <span class="n">g</span><span class="o">++</span> <span class="o">-</span><span class="n">g</span> <span class="o">-</span><span class="n">o</span> <span class="n">cv</span> <span class="n">cv</span><span class="p">.</span><span class="n">cpp</span> <span class="o">-</span><span class="n">lpthread</span>
<span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">localhost</span> <span class="n">testsemaphore</span><span class="p">]</span><span class="err">#</span> <span class="p">.</span><span class="o">/</span><span class="n">cv</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571242518272</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571225732864</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571208947456</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571242518272</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571234125568</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571217340160</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571225732864</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571208947456</span>
<span class="n">produce</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571200554752</span>
<span class="n">handle</span> <span class="n">a</span> <span class="n">task</span><span class="p">,</span> <span class="nl">taskID</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="nl">threadID</span><span class="p">:</span> <span class="mi">140571242518272</span>
<span class="p">...</span><span class="err">更多输出结果省略</span><span class="p">...</span>
</code></pre></td></tr></table>
</div>
</div><p>条件变量最关键的一个地方就是需要清楚地记得 <strong>pthread_cond_wait</strong> 在条件满足与不满足时的两种行为，这是难点也是<strong>重点</strong>：</p>
<ul>
<li>当 <strong>pthread_cond_wait</strong> 函数阻塞时，它会释放其绑定的互斥体，并阻塞线程，因此在调用该函数前应该对互斥体有个加锁操作（上述代码的第 <strong>34</strong> 行的 pthread_mutex_lock(&amp;mymutex);）。</li>
<li>当收到条件信号时， <strong>pthread_cond_wait</strong> 会返回并对其绑定的互斥体进行加锁，因此在其下面一定有个对互斥体进行解锁的操作（上述代码的第 <strong>45</strong> 行 pthread_mutex_unlock(&amp;mymutex);）。</li>
</ul>
<h4 id="条件变量的虚假唤醒">条件变量的虚假唤醒</h4>
<hr>
<p>上面将互斥量和条件变量配合使用的示例代码中有个很有意思的地方，就是用了 while 语句，醒来
之后要再次判断条件是否满足。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">while</span> <span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="p">{</span>
	<span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mycv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>为什么不写成：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span> <span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<span class="p">{</span>
	<span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mycv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mymutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>答案是不得不如此。因为可能某次操作系统唤醒 pthread_cond_wait 时 tasks.empty() 可能仍然为 true，言下之意就是操作系统可能会在一些情况下唤醒条件变量，即使没有其他线程向条件变量发送信号，等待此条件
变量的线程也有可能会醒来。我们将条件变量的这种行为称之为 <strong>虚假唤醒</strong> （<strong>spurious wakeup</strong>）。因此将条件（判断 tasks.empty() 为true）放在一个 while 循环中意味着光唤醒条件变量不行，还必须条件满足程序才能继续执行正常的逻辑。</p>
<p>这看起来这像是个bug，但它在 Linux 系统中是实实在在存在的。为什么会存在虚假唤醒呢？一个原因是
<strong>pthread_cond_wait</strong> 是 futex 系统调用，属于阻塞型的系统调用，当系统调用被信号中断的时候，会返回 <strong>-1</strong>，并且把 errno 错误码置为EINTR。很多这种系统调用为了防止被信号中断都会重启系统调用（即再次调用一次这个函数），代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pid_t</span> <span class="nf">r_wait</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">stat_loc</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">retval</span><span class="p">;</span>
    <span class="c1">//wait函数因为被信号中断导致调用失败会返回-1，错误码是EINTR
</span><span class="c1"></span>    <span class="c1">//注意：这里的while循环体是一条空语句
</span><span class="c1"></span>    <span class="k">while</span><span class="p">(((</span><span class="n">retval</span> <span class="o">=</span> <span class="n">wait</span><span class="p">(</span><span class="n">stat_loc</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">errno</span> <span class="o">==</span> <span class="n">EINTR</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>但是 <strong>pthread_cond_wait</strong> 用途有点不一样，假设 <strong>pthread_cond_wait</strong> 函数被信号中断了，在 <strong>pthread_cond_wait</strong> 返回之后，到重新调用之前，<strong>pthread_cond_signal</strong> 或
<strong>pthread_cond_broadcast</strong> 可能已经调用过。一旦错失，可能由于条件信号不再产生，再次调用 <strong>pthread_cond_wait</strong> 将导致程序无限制地等待下去。为了避免这种情况，宁可虚假唤醒，也不能再次调用<strong>pthread_cond_wait</strong>，以免陷入无穷的等待中。</p>
<p>除了上面的信号因素外，还存在以下情况：条件满足了发送信号，但等到调用 <strong>pthread_cond_wait</strong> 的线程得到 CPU 资源时，条件又再次不满足了。</p>
<p>好在无论是哪种情况，醒来之后再次测试条件是否满足就可以解决虚假等待的问题。<strong>这就是使用 while 循环来判断条件，而不是使用 if 语句的原因。</strong></p>
<h4 id="条件变量信号丢失问题">条件变量信号丢失问题</h4>
<hr>
<p>上文中，我们介绍了，如果一个条件变量信号条件产生时（调用 <strong>pthread_cond_signal</strong> 或
<strong>pthread_cond_broadcast</strong>），没有相关的线程调用 <strong>pthread_cond_wait</strong> 捕获该信号，那么该信号条件就会永久性地丢失了，再次调用 <strong>pthread_cond_wait</strong> 会导致永久性的阻塞。这种情况在设计那些条件变量信号条件只会产生一次的逻辑中尤其需要注意，例如假设现在某个程序有一批等待条件变量的线程，和一个只产生一次条件变量信号的线程。为了让你的等待条件变量的线程能正常运行不阻塞，你的逻辑中，一定要确保等待的线程在产生条件变量信号的线程发送条件信号之前调用 <strong>pthread_cond_wait</strong> 。</p>
<blockquote>
<p>这和生活中的很多例子一样，即许多事情你只有一次机会，你必须提前准备好再去尝试这次机会，这个机会不会等待你的准备，一旦你错过，就不会再有第二次机会了。</p>
</blockquote>
<p>条件变量是最常用的一种多线程编程同步技术之一。</p>
<h3 id="linux-读写锁">LINUX 读写锁</h3>
<hr>
<h4 id="读写锁的应用场景">读写锁的应用场景</h4>
<hr>
<p>实际应用中，很多时候对共享变量的访问有以下特点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-fallback" data-lang="fallback">大多数情况下线程只是读取共享变量的值，并不修改，只有极少数情况下，线程才会真正地修改共享变量的值。
</code></pre></td></tr></table>
</div>
</div><p>对于这种情况，读请求之间是无需同步的，它们之间的并发访问是安全的。然而写请求必须锁住读请求和其他写请求。</p>
<p>这种情况在实际中是存在的，如读取一个全局对象的状态属性，大多数情况下这个状态属性值是不会变化的，偶尔才会出现被修改的情况。如果使用互斥量，完全阻止读请求并发，则会造成性能的损失。</p>
<h4 id="读写锁使用方法">读写锁使用方法</h4>
<hr>
<p>读写锁在 Linux 系统中使用类型 <strong>pthread_rwlock_t</strong> 表示，读写锁的初始化和销毁使用如下系统 API 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_rwlock_init</span><span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">,</span> <span class="k">const</span> <span class="n">pthread_rwlockattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_rwlock_destroy</span><span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>参数 <strong>rwlock</strong> 即你需要初始化和销毁的读写锁对象的地址， 参数 <strong>attr</strong> 用于设置读写锁的属性，一般设置未 NULL 表示使用默认属性。函数调用成功返回 0，调用失败返回非 0 值，你可以通过检测错误码 <strong>errno</strong> 获取错误原因。</p>
<p>当然，如果你不需要动态创建或者设置非默认属性的读写锁对象，你也可以使用如下语法初始化一个读写锁对象：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pthread_rwlock_t</span> <span class="n">myrwlock</span> <span class="o">=</span> <span class="n">PTHREAD_RWLOCK_INITIALIZER</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>下面是三个请求读锁的系统 API 接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_rwlock_rdlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_rwlock_tryrdlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_rwlock_timedrdlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">abstime</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>而下面三个请求写锁的系统 API 接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_rwlock_wrlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_rwlock_trywrlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_rwlock_timedwrlock</span><span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span><span class="o">*</span> <span class="n">abstime</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>读锁用于共享模式</strong>：</p>
<ul>
<li>如果当前读写锁已经被某线程以<strong>读模式</strong>占有了，其他线程调用 <strong>pthread_rwlock_rdlock</strong> （请求读锁）会立刻获得读锁；</li>
<li>如果当前读写锁已经被某线程以<strong>读模式</strong>占有了，其他线程调用 <strong>pthread_rwlock_wrlock</strong> （请求写锁）会陷入<strong>阻塞</strong>；</li>
</ul>
<p><strong>写锁用的是独占模式</strong>：</p>
<ul>
<li>如果当前读写锁被某线程以<strong>写模式</strong>占有，无论调用 <strong>pthread_rwlock_rdlock</strong> 还是 <strong>pthread_rwlock_wrlock</strong> ** 都会陷入<strong>阻塞</strong>，即写模式下不允许任何<strong>读锁</strong>请求通过，也不允许任何<strong>写锁</strong>请求通过，读锁请求和写锁请求都要陷入阻塞，直到线程释放写锁。</li>
</ul>
<p>可以将上述读写锁逻辑总结成如下表格：</p>
<table>
<thead>
<tr>
<th>锁当前状态/其他线程请求锁类型</th>
<th>请求读锁</th>
<th>请求写锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁</td>
<td>通过</td>
<td>通过</td>
</tr>
<tr>
<td>已经获得读锁</td>
<td>通过</td>
<td>阻止</td>
</tr>
<tr>
<td>已经获得写锁</td>
<td>阻止</td>
<td>阻止</td>
</tr>
</tbody>
</table>
<p>无论是读锁还是写锁，锁的释放都是一个接口：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_rwlock_unlock</span> <span class="p">(</span><span class="n">pthread_rwlock_t</span><span class="o">*</span> <span class="n">rwlock</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>无论是请求读锁还是写锁，都提供了trylock的功能（<strong>pthread_rwlock_tryrdlock</strong> 和 <strong>pthread_rwlock_trywrlock</strong>），调用线程不会阻塞，而会立即返回。如果能成功获得读锁或者写锁，函数返回 0，如果不能获得读锁或写锁时，函数返回非 0 值，此时错误码 errno 是 EBUSY。</p>
<p>当然，无论是请求读锁还是写锁都提供了限时等待功能，如果不能获取读写锁，则会陷入阻塞，最多等待到参数 <strong>abstime</strong> 设置的时间，如果仍然无法获得锁，则返回，错误码 errno 是 ETIMEOUT。</p>
<h4 id="读写锁的属性">读写锁的属性</h4>
<hr>
<p>上文介绍 <strong>pthread_rwlock_init</strong> 函数时，提到其第二个参数可以设置读写锁的属性，读写锁的属性类型是 <strong>pthread_rwlockattr_t</strong> ，glibc 引入了如下接口来查询和改变读写锁的类型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="nf">pthread_rwlockattr_setkind_np</span><span class="p">(</span><span class="n">pthread_rwlockattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pref</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_rwlockattr_getkind_np</span><span class="p">(</span><span class="k">const</span> <span class="n">pthread_rwlockattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">pref</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p><strong>pthread_rwlockattr_setkind_np</strong> 的第二个参数 <strong>pref</strong> 即设置读写锁的类型，其取值有如下几种：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">enum</span>
<span class="p">{</span>
    <span class="c1">//读者优先(即同时请求读锁和写锁时，请求读锁的线程优先获得锁)
</span><span class="c1"></span>    <span class="n">PTHREAD_RWLOCK_PREFER_READER_NP</span><span class="p">,</span>
    <span class="c1">//不要被名字所迷惑，也是读者优先
</span><span class="c1"></span>    <span class="n">PTHREAD_RWLOCK_PREFER_WRITER_NP</span><span class="p">,</span>
    <span class="c1">//写者优先(即同时请求读锁和写锁时，请求写锁的线程优先获得锁)
</span><span class="c1"></span>    <span class="n">PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</span><span class="p">,</span>
    <span class="n">PTHREAD_RWLOCK_DEFAULT_NP</span> <span class="o">=</span> <span class="n">PTHREAD_RWLOCK_PREFER_READER_NP</span>
<span class="p">};</span>
</code></pre></td></tr></table>
</div>
</div><p>当然，为了得到一个有效的 <strong>pthread_rwlockattr_t</strong> 对象，你需要调用 <strong>pthread_rwlockattr_init</strong> 函数初始化这样一个属性对象，在你不需要的时候记得使用 <strong>pthread_rwlockattr_destroy</strong> 销毁之：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">int</span> <span class="nf">pthread_rwlockattr_init</span><span class="p">(</span><span class="n">pthread_rwlockattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">pthread_rwlockattr_destroy</span><span class="p">(</span><span class="n">pthread_rwlockattr_t</span><span class="o">*</span> <span class="n">attr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>以下代码片段演示了如何初始化一个写者优先的读写锁：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pthread_rwlockattr_t</span> <span class="n">attr</span><span class="p">;</span>
<span class="n">pthread_rwlockattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
<span class="n">pthread_rwlockattr_setkind_np</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</span><span class="p">);</span>
<span class="n">pthread_rwlock_t</span> <span class="n">rwlock</span><span class="p">;</span>
<span class="n">pthread_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rwlock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="读写锁使用示例">读写锁使用示例</h4>
<hr>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">resourceID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pthread_rwlock_t</span> <span class="n">myrwlock</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">read_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//请求读锁
</span><span class="c1"></span>		<span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;read thread ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, resourceID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">resourceID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="c1">//使用睡眠模拟读线程读的过程消耗了很久的时间
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">write_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//请求写锁
</span><span class="c1"></span>		<span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

		<span class="o">++</span><span class="n">resourceID</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;write thread ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, resourceID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">resourceID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="c1">//使用睡眠模拟读线程读的过程消耗了很久的时间
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="c1">//创建5个请求读锁线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">readThreadID</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">read_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//创建一个请求写锁线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">writeThreadID</span><span class="p">;</span>
	<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">writeThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">write_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">pthread_join</span><span class="p">(</span><span class="n">writeThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">readThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pthread_rwlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述程序中创建五个请求读锁的“读”线程和一个请求写锁的“写”线程，共享的资源是一个整形变量 <strong>resourceID</strong>，我们编译并执行得到输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># g++ -g -o rwlock rwlock.cpp -lpthread</span>
<span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># ./rwlock</span>
<span class="nb">read</span> thread ID: 140575861593856, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: 140575878379264, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: 140575853201152, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: 140575869986560, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: 140575886771968, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: <span class="nb">read</span> thread ID: <span class="nb">read</span> thread ID: <span class="nb">read</span> thread ID: 140575861593856140575886771968, resourceID: 0, resourceID:
<span class="m">0</span>
140575878379264read thread ID: 140575869986560, resourceID: <span class="m">0</span>
, resourceID: <span class="m">0</span>
140575853201152, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: <span class="nb">read</span> thread ID: <span class="nb">read</span> thread ID: 140575861593856140575853201152140575886771968, resourceID: , resourceID: 0, resourceID: <span class="m">00</span>


<span class="nb">read</span> thread ID: 140575869986560, resourceID: <span class="m">0</span>
...更多输出结果省略...
</code></pre></td></tr></table>
</div>
</div><p>上述输出结果，我们验证了两个结论：</p>
<ul>
<li>由于读写锁对象 <strong>myrwlock</strong> 使用了默认属性，其行为是请求读锁的线程优先获得到锁，请求写锁的线程 <strong>write_thread</strong> 很难获得锁的机会，因此结果中基本没有请求写锁线程的输出结果。</li>
<li>由于多个请求读锁的线程 <strong>read_thread</strong> 可以自由获得读锁，且代码 <strong>15</strong> 行（std::cout &laquo; “read thread ID: “ &laquo; pthread_self() &laquo; “, resourceID: “ &laquo; resourceID &laquo; std::endl;）的输出不是原子性的，所以多个“读”线程的输出可能会交替，出现“错乱”现象。</li>
</ul>
<p>我们将读写锁对象 <strong>myrwlock</strong> 的属性修改成请求写锁优先，再来试一试：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">resourceID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pthread_rwlock_t</span> <span class="n">myrwlock</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">read_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//请求读锁
</span><span class="c1"></span>		<span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;read thread ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, resourceID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">resourceID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="c1">//使用睡眠模拟读线程读的过程消耗了很久的时间
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">write_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//请求写锁
</span><span class="c1"></span>		<span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

		<span class="o">++</span><span class="n">resourceID</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;write thread ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, resourceID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">resourceID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="c1">//使用睡眠模拟读线程读的过程消耗了很久的时间
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_rwlockattr_t</span> <span class="n">attr</span><span class="p">;</span>
	<span class="n">pthread_rwlockattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="c1">//设置成请求写锁优先
</span><span class="c1"></span>	<span class="n">pthread_rwlockattr_setkind_np</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</span><span class="p">);</span>
	<span class="n">pthread_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

	<span class="c1">//创建5个请求读锁线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">readThreadID</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">read_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//创建一个请求写锁线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">writeThreadID</span><span class="p">;</span>
	<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">writeThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">write_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">pthread_join</span><span class="p">(</span><span class="n">writeThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">readThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pthread_rwlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译程序并运行，输出结果如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># g++ -g -o rwlock2 rwlock2.cpp -lpthread</span>
<span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># ./rwlock2</span>
<span class="nb">read</span> thread ID: 140122217539328, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: 140122242717440, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: 140122209146624, resourceID: <span class="m">0</span>
write thread ID: 140122200753920, resourceID: <span class="m">1</span>
<span class="nb">read</span> thread ID: 140122234324736, resourceID: <span class="m">1</span>
write thread ID: 140122200753920, resourceID: <span class="m">2</span>
write thread ID: 140122200753920, resourceID: <span class="m">3</span>
write thread ID: 140122200753920, resourceID: <span class="m">4</span>
write thread ID: 140122200753920, resourceID: <span class="m">5</span>
write thread ID: 140122200753920, resourceID: <span class="m">6</span>
write thread ID: 140122200753920, resourceID: <span class="m">7</span>
write thread ID: 140122200753920, resourceID: <span class="m">8</span>
write thread ID: 140122200753920, resourceID: <span class="m">9</span>
write thread ID: 140122200753920, resourceID: <span class="m">10</span>
write thread ID: 140122200753920, resourceID: <span class="m">11</span>
write thread ID: 140122200753920, resourceID: <span class="m">12</span>
write thread ID: 140122200753920, resourceID: <span class="m">13</span>
<span class="nb">read</span> thread ID: 140122217539328, resourceID: <span class="m">13</span>
write thread ID: 140122200753920, resourceID: <span class="m">14</span>
write thread ID: 140122200753920, resourceID: <span class="m">15</span>
write thread ID: 140122200753920, resourceID: <span class="m">16</span>
write thread ID: 140122200753920, resourceID: <span class="m">17</span>
write thread ID: 140122200753920, resourceID: <span class="m">18</span>
write thread ID: 140122200753920, resourceID: <span class="m">19</span>
write thread ID: 140122200753920, resourceID: <span class="m">20</span>
write thread ID: 140122200753920, resourceID: <span class="m">21</span>
write thread ID: 140122200753920, resourceID: <span class="m">22</span>
write thread ID: 140122200753920, resourceID: <span class="m">23</span>
...更多输出结果省略...
</code></pre></td></tr></table>
</div>
</div><p>由于将 <strong>myrwlock</strong> 设置成请求写锁优先，上述结果中几乎都是 <strong>write_thread</strong> 的输出结果。</p>
<p>我们将 <strong>write_thread</strong> 中的 <strong>37</strong> 行 sleep 语句挪到 <strong>39</strong> 行后面，增加请求写锁线程的睡眠时间，再看看执行结果。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="kt">int</span> <span class="n">resourceID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">pthread_rwlock_t</span> <span class="n">myrwlock</span><span class="p">;</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">read_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//请求读锁
</span><span class="c1"></span>		<span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;read thread ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, resourceID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">resourceID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="c1">//使用睡眠模拟读线程读的过程消耗了很久的时间
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span><span class="o">*</span> <span class="nf">write_thread</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//请求写锁
</span><span class="c1"></span>		<span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

		<span class="o">++</span><span class="n">resourceID</span><span class="p">;</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;write thread ID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">pthread_self</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;, resourceID: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">resourceID</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

		<span class="c1">//放在这里增加请求读锁线程获得锁的几率
</span><span class="c1"></span>		<span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">pthread_rwlockattr_t</span> <span class="n">attr</span><span class="p">;</span>
	<span class="n">pthread_rwlockattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
	<span class="c1">//设置成请求写锁优先
</span><span class="c1"></span>	<span class="n">pthread_rwlockattr_setkind_np</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP</span><span class="p">);</span>
	<span class="n">pthread_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

	<span class="c1">//创建5个请求读锁线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">readThreadID</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">readThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">read_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="c1">//创建一个请求写锁线程
</span><span class="c1"></span>	<span class="n">pthread_t</span> <span class="n">writeThreadID</span><span class="p">;</span>
	<span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">writeThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">write_thread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">pthread_join</span><span class="p">(</span><span class="n">writeThreadID</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pthread_join</span><span class="p">(</span><span class="n">readThreadID</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pthread_rwlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">myrwlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>再次编译程序并执行，得到输出结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell"><span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># g++ -g -o rwlock3 rwlock3.cpp -lpthread</span>
<span class="o">[</span>root@localhost testmultithread<span class="o">]</span><span class="c1"># ./rwlock3</span>
<span class="nb">read</span> thread ID: 140315524790016, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: 140315549968128, resourceID: <span class="m">0</span>
<span class="nb">read</span> thread ID: 140315541575424, resourceID: <span class="m">0</span>
write thread ID: 140315508004608, resourceID: <span class="m">1</span>
<span class="nb">read</span> thread ID: 140315549968128, resourceID: <span class="m">1</span>
<span class="nb">read</span> thread ID: 140315541575424, resourceID: <span class="m">1</span>
<span class="nb">read</span> thread ID: 140315524790016, resourceID: <span class="m">1</span>
<span class="nb">read</span> thread ID: 140315516397312, resourceID: <span class="m">1</span>
<span class="nb">read</span> thread ID: 140315533182720, resourceID: <span class="m">1</span>
write thread ID: 140315508004608, resourceID: <span class="m">2</span>
<span class="nb">read</span> thread ID: 140315541575424, resourceID: <span class="m">2</span>
<span class="nb">read</span> thread ID: 140315524790016, resourceID: <span class="m">2</span>
<span class="nb">read</span> thread ID: 140315533182720, resourceID: <span class="m">2</span>
<span class="nb">read</span> thread ID: 140315516397312, resourceID: <span class="m">2</span>
<span class="nb">read</span> thread ID: 140315549968128, resourceID: <span class="m">2</span>
<span class="nb">read</span> thread ID: 140315516397312, resourceID: <span class="m">2</span>
write thread ID: 140315508004608, resourceID: <span class="m">3</span>
<span class="nb">read</span> thread ID: 140315549968128, resourceID: <span class="m">3</span>
<span class="nb">read</span> thread ID: 140315541575424, resourceID: <span class="m">3</span>
<span class="nb">read</span> thread ID: 140315533182720, resourceID: 3read thread ID: <span class="nb">read</span> thread ID: 140315524790016, resourceID: <span class="m">3</span>
140315516397312, resourceID: <span class="m">3</span>

<span class="nb">read</span> thread ID: <span class="nb">read</span> thread ID: <span class="nb">read</span> thread ID: 140315524790016140315549968128, resourceID: , resourceID: <span class="m">33</span>
140315516397312, resourceID: <span class="m">3</span>
<span class="nb">read</span> thread ID: 140315541575424, resourceID: <span class="nb">read</span> thread ID: 140315533182720, resourceID: <span class="m">3</span>
<span class="m">3</span>

write thread ID: 140315508004608, resourceID: <span class="m">4</span>
<span class="nb">read</span> thread ID: 140315516397312, resourceID: <span class="m">4</span>
<span class="nb">read</span> thread ID: 140315541575424, resourceID: <span class="m">4</span>
<span class="nb">read</span> thread ID: 140315524790016, resourceID: <span class="m">4</span>
<span class="nb">read</span> thread ID: 140315549968128, resourceID: <span class="m">4</span>
<span class="nb">read</span> thread ID: 140315533182720, resourceID: <span class="m">4</span>
<span class="nb">read</span> thread ID: 140315524790016, resourceID: <span class="m">4</span>
<span class="nb">read</span> thread ID: 140315541575424, resourceID: <span class="m">4</span>
write thread ID: 140315508004608, resourceID: <span class="m">5</span>
<span class="nb">read</span> thread ID: 140315516397312, resourceID: <span class="m">5</span>
<span class="nb">read</span> thread ID: 140315541575424, resourceID: <span class="m">5</span>
<span class="nb">read</span> thread ID: 140315524790016, resourceID: <span class="m">5</span>
<span class="nb">read</span> thread ID: 140315533182720, resourceID: <span class="m">5</span>
<span class="nb">read</span> thread ID: 140315549968128, resourceID: <span class="m">5</span>
</code></pre></td></tr></table>
</div>
</div><p>这次请求读锁的线程和请求写锁的线程的输出结果分布就比较均匀了。</p>
<h2 id="5-如何确保创建的线程一定运行起来">5. 如何确保创建的线程一定运行起来？</h2>
<hr>
<p>在本章开头的小节里面我们介绍了如何创建线程，但是很少有人会注意到创建的线程如何确保一定运行起来了？很多人会说，对于使用系统 API 创建的线程，只需要判断一下创建的线程函数是否是调用成功的，这只做了一步，线程函数调用成功，也没法百分百保证线程函数一定运行起来了。</p>
<p>在一些“古老”或者“严谨”的项目中，你会发现这些代码创建线程时不仅判断线程创建函数是否调用成功，还会在线程函数中利用上文介绍的一些线程同步对象来通知线程的创建者线程是否创建成功。我们来看一段这样的代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> 				<span class="n">mymutex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">mycv</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">thread_func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mymutex</span><span class="p">);</span>
        <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">mycv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//实际的线程执行的工作代码放在下面
</span><span class="c1"></span>    <span class="c1">//这里为了模拟方便，简单地写个死循环
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="kr">thread</span> <span class="n">t</span><span class="p">(</span><span class="n">thread_func</span><span class="p">);</span>

    <span class="c1">//使用花括号减小锁的粒度
</span><span class="c1"></span>    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mymutex</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">mycv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;start thread successfully.&#34;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码，发出一个创建新线程的请求后，立刻阻塞在一个条件变量上，工作线程如果成功运行起来，会发送条件变量信号告知主线程，这样主线程就知道新线程一定成功运行起来了。</p>
<p>基于以上思路，我们创建一组线程时，可以一个地创建，每成功运行一个新线程再创建下一个，确保线程组中的每一个线程都可以运行起来。示例代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="cp">#include</span> <span class="cpf">&lt;thread&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;mutex&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;condition_variable&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span><span class="cp"></span>
<span class="n">std</span><span class="o">::</span><span class="n">mutex</span> 				<span class="n">mymutex</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">condition_variable</span> <span class="n">mycv</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">success</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">thread_func</span><span class="p">()</span>
<span class="p">{</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mymutex</span><span class="p">);</span>
        <span class="n">success</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">mycv</span><span class="p">.</span><span class="n">notify_all</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">//实际的线程执行的工作代码放在下面
</span><span class="c1"></span>    <span class="c1">//这里为了模拟方便，简单地写个死循环
</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span>
    <span class="p">{</span>

    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;&gt;</span> <span class="n">threads</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="o">&gt;</span> <span class="n">spthread</span><span class="p">;</span>
        <span class="n">spthread</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">new</span> <span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="p">(</span><span class="n">thread_func</span><span class="p">));</span>

        <span class="c1">//使用花括号减小锁的粒度
</span><span class="c1"></span>        <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mymutex</span><span class="p">);</span>
            <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">mycv</span><span class="p">.</span><span class="n">wait</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&#34;start thread successfully， index: &#34;</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

        <span class="n">threads</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spthread</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">iter</span> <span class="p">:</span> <span class="n">threads</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">iter</span><span class="o">-&gt;</span><span class="n">join</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>编译上述程序并运行，结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-shell" data-lang="shell">root on 127.0.0.1.16clouds.com in ~
$ g++ -g -o makesurethreadgroup makesurethreadgroup.cpp -std<span class="o">=</span>c++0x -lpthread
root on 127.0.0.1.16clouds.com in ~
$ ./makesurethreadgroup
start thread successfully， index: <span class="m">0</span>
start thread successfully， index: <span class="m">1</span>
start thread successfully， index: <span class="m">2</span>
start thread successfully， index: <span class="m">3</span>
start thread successfully， index: <span class="m">4</span>
</code></pre></td></tr></table>
</div>
</div><p>可以看到，新线程挨个运行起来。当然，你不一定要使用条件变量，也可以使用其他类型的线程同步对象，如 Windows 平台的 Event 对象等等。</p>
<h2 id="6-锁使用实践经验总结">6. 锁使用实践经验总结</h2>
<hr>
<h3 id="减少锁的使用">减少锁的使用</h3>
<hr>
<p>实际开发中能不使用锁尽量不使用锁，当然这不是绝对的，如果使用锁也能满足性能要求，使用锁也无妨，一般使用了锁的代码会带来如下性能损失：</p>
<ul>
<li>加锁和解锁操作，本身有一定的开销；</li>
<li>临界区的代码不能并发执行；</li>
<li>进入临界区的次数过于频繁，线程之间对临界区的争夺太过激烈，若线程竞争互斥量失败，就会陷入阻塞，让出 CPU，所以执行上下文切换的次数要远远多于不使用互斥量的版本。</li>
</ul>
<p>替代锁的方式有很多，如无锁队列。</p>
<h3 id="明确锁的范围">明确锁的范围</h3>
<hr>
<p>看下面这段代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="k">if</span><span class="p">(</span><span class="n">hashtable</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">htable_insert</span><span class="p">(</span><span class="n">hashtable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>能看出这段代码的问题吗？代码行 <strong>4</strong> 虽然对 <strong>hashtable</strong> 的插入使用了锁做保护，但是判断 <strong>hash_table</strong> 是否为空也需要使用锁保护，所以正确的写法应该是：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">hashtable</span><span class="p">.</span><span class="n">is_empty</span><span class="p">())</span>
<span class="p">{</span>
    <span class="n">htable_insert</span><span class="p">(</span><span class="n">hashtable</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elem</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="减少锁的粒度">减少锁的粒度</h3>
<hr>
<p>所谓减小锁使用粒度指的是尽量减小锁作用的临界区代码范围，临界区的代码范围越小，多个线程排队进入临界区的时间就会越短。这就类似高速公路上堵车，如果堵车的路段越长，那么后续过来的车辆通行等待时间就会越长。</p>
<p>我们来看两个具体的例子：</p>
<p><strong>示例一</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">TaskPool</span><span class="o">::</span><span class="n">addTask</span><span class="p">(</span><span class="n">Task</span><span class="o">*</span> <span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">m_mutexList</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span> <span class="n">spTask</span><span class="p">;</span>
    <span class="n">spTask</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>
    <span class="n">m_taskList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spTask</span><span class="p">);</span>

    <span class="n">m_cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码中 <strong>guard</strong> 锁保护 <strong>m_taskList</strong>，仔细分析下这段代码发现，代码行 <strong>4</strong>、<strong>5</strong> 和 <strong>8</strong> 行其实没必要作为临界区内的代码的，所以建议挪到临界区外面去，修改如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">TaskPool</span><span class="o">::</span><span class="n">addTask</span><span class="p">(</span><span class="n">Task</span><span class="o">*</span> <span class="n">task</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Task</span><span class="o">&gt;</span> <span class="n">spTask</span><span class="p">;</span>
    <span class="n">spTask</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="n">task</span><span class="p">);</span>

    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">(</span><span class="n">m_mutexList</span><span class="p">);</span>
        <span class="n">m_taskList</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">spTask</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">m_cv</span><span class="p">.</span><span class="n">notify_one</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>修改之后， <strong>guard</strong> 锁的作用范围就是 <strong>7</strong> 、<strong>8</strong> 两行了，仅对 **m_taskList.push_back() **操作做保护，这样锁的粒度就变小了。</p>
<p><strong>示例二</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">doPendingFunctors</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pendingFunctors_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">pendingFunctors_</span><span class="p">[</span><span class="n">i</span><span class="p">]();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述代码中 **pendingFunctors_** 是被锁保护的对象，它的类型是 **std::vector**，这样的代码效率比较低，必须等当前线程挨个处理完 **pendingFunctors_** 中的元素后其他线程才能操作 **pendingFunctors_** 。修改代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="n">EventLoop</span><span class="o">::</span><span class="n">doPendingFunctors</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Functor</span><span class="o">&gt;</span> <span class="n">functors</span><span class="p">;</span>

	<span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">unique_lock</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lock</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
		<span class="n">functors</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">pendingFunctors_</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">functors</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">functors</span><span class="p">[</span><span class="n">i</span><span class="p">]();</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>修改之后的代码使用了一个局部变量 <strong>functors</strong>，然后把 **pendingFunctors_** 中的内容倒换到 **functors** 中，这样就可以释放锁了，允许其他线程操作 **pendingFunctors_** ，现在只要继续操作本地对象 **functors** 就可以了，提高了效率。</p>
<h3 id="避免死锁的一些建议">避免死锁的一些建议</h3>
<ul>
<li><strong>一个函数中，如果有一个加锁操作，那么一定要记得在函数退出时记得解锁，且每个退出路径上都不要忘记解锁路径。</strong></li>
</ul>
<p>例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-c" data-lang="c"><span class="kt">void</span> <span class="nf">some_func</span><span class="p">()</span>
<span class="p">{</span>
	<span class="c1">//加锁代码
</span><span class="c1"></span>
	<span class="k">if</span> <span class="p">(</span><span class="err">条件</span><span class="mi">1</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="c1">//其他代码
</span><span class="c1"></span>		<span class="c1">//解锁代码
</span><span class="c1"></span>		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">else</span>
	<span class="p">{</span>
		<span class="c1">//其他代码
</span><span class="c1"></span>		<span class="c1">//解锁代码
</span><span class="c1"></span>		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="err">条件</span><span class="mi">2</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="err">条件</span><span class="mi">3</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">//其他代码
</span><span class="c1"></span>			<span class="c1">//解锁代码
</span><span class="c1"></span>			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="err">条件</span><span class="mi">4</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">//其他代码
</span><span class="c1"></span>			<span class="c1">//解锁代码
</span><span class="c1"></span>			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="err">条件</span><span class="mi">5</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="err">条件</span><span class="mi">6</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="c1">//其他代码
</span><span class="c1"></span>			<span class="c1">//解锁代码
</span><span class="c1"></span>			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>上述函数中每个逻辑出口处都需要写上解锁代码。前面也说过，这种逻辑非常容易因为疏忽忘记在某个地方加上解锁代码而造成死锁，所以一般建议使用 RAII 技术将加锁和解锁代码封装起来。</p>
<ul>
<li><strong>线程退出时一定要及时释放其持有的锁</strong></li>
</ul>
<p>实际开发中会因一些特殊需求创建一些临时线程，这些线程执行完相应的任务后就会退出。对于这类线程，如果其持有了锁，一定记得在线程退出时记得释放其持有的锁对象。</p>
<ul>
<li><strong>多线程请求锁的方向要一致，以避免死锁</strong></li>
</ul>
<p>假设现在有两个锁 A 和 B，线程 1 在请求了锁 A 之后再请求 B，线程 2 在请求了锁 B 后再请求锁 A，这种线程请求锁的方向就不一致了，线程 1 的方向是从 A 到 B，线程 2 的方向是从 B 到 A，多个线程请求锁的方向不一致容易造成死锁。所以建议的方式是 线程 1 和 线程 2 请求锁的方向保持一致，要么都从 A 到 B，要么都从 B 到 A。</p>
<ul>
<li><strong>当需要同一个线程重复请求一个锁时，搞清楚你所使用的锁的行为，是递增锁引用计数，还是会阻塞抑或是直接获得锁？</strong></li>
</ul>
<h3 id="避免活锁的一些建议">避免活锁的一些建议</h3>
<p>前面说了避免“死锁”，读者应该能理解，但是这里突然出现了避免“活锁”，我相信很多人看到这个标题一下子就懵了。所谓活锁就是，当多个线程使用 <strong>trylock</strong> 系列的函数时，由于多个线程相互谦让，导致即使在某段时间内锁资源是可用的，也可能导致需要锁的线程拿不到锁。举个生活中的例子，马路上两个人迎面走来，两个人同时往一个方向避让，原来本意是给对方让路，结果还是发生了碰撞。</p>
<p>我们在实际编码时，尽量避免不要过多的线程使用 <strong>trylock</strong> 请求锁，以免出现“活锁”现象，这是对资源的一种浪费。</p>
<h2 id="7-线程局部存储">7. 线程局部存储</h2>
<hr>

    </div>

    
    
<div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">rubinera1n</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
      2020-07-05
      
        <a href="https://github.com/rubinera1n/blogs/commit/61941393fa702c7e993ebedb22f30836cf2d6d0d" title="update">
          (6194139)
        </a>
        
      
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>


    
    

    <footer class="post-footer">
      <div class="post-tags">
          <a href="https://blog.xiufuguo.com/tags/linux/">linux</a>
          
        </div>

      
      <nav class="post-nav">
        
        
          <a class="next" href="/post/programmer_code_interview_guide/ch02_linked_list/05_reverse_part_of_one_way_linked_list/">
            <span class="next-text nav-default">[链表] 05.反转部分单向链表</span>
            <span class="prev-text nav-mobile">Next</span>
            
            <i class="iconfont">
              <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="18" height="18">
  <path d="M332.091514 74.487481l-75.369571 89.491197c-10.963703 12.998035-10.285251 32.864502 1.499144 44.378743l286.278095 300.375162L266.565125 819.058374c-11.338233 12.190647-11.035334 32.285311 0.638543 44.850487l80.46666 86.564541c11.680017 12.583596 30.356378 12.893658 41.662889 0.716314l377.434212-421.426145c11.332093-12.183484 11.041474-32.266891-0.657986-44.844348l-80.46666-86.564541c-1.772366-1.910513-3.706415-3.533476-5.750981-4.877077L373.270379 71.774697C361.493148 60.273758 343.054193 61.470003 332.091514 74.487481z"></path>
</svg>

            </i>
          </a>
      </nav>
    </footer>
  </article>

  
  
  
  

  
  

  

  
  
    <div class="post bg-white">
      <script src="https://utteranc.es/client.js"
            repo= "rubinera1n/comments"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
      </script>
    </div>
  

  

  

  

    

  

        </div>
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="icon-links">
  
  
    <a href="mailto:rubinera1n@gmail.com" rel="me noopener" class="iconfont"
      title="email" >
      <svg class="icon" viewBox="0 0 1451 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M664.781909 681.472759 0 97.881301C0 3.997201 71.046997 0 71.046997 0L474.477909 0 961.649408 0 1361.641813 0C1361.641813 0 1432.688811 3.997201 1432.688811 97.881301L771.345323 681.472759C771.345323 681.472759 764.482731 685.154773 753.594283 688.65053L753.594283 688.664858C741.602731 693.493018 729.424896 695.068979 718.077952 694.839748 706.731093 695.068979 694.553173 693.493018 682.561621 688.664858L682.561621 688.65053C671.644501 685.140446 664.781909 681.472759 664.781909 681.472759L664.781909 681.472759ZM718.063616 811.603883C693.779541 811.016482 658.879232 802.205449 619.10784 767.734955 542.989056 701.759633 0 212.052267 0 212.052267L0 942.809523C0 942.809523 0 1024 83.726336 1024L682.532949 1024 753.579947 1024 1348.948139 1024C1432.688811 1024 1432.688811 942.809523 1432.688811 942.809523L1432.688811 212.052267C1432.688811 212.052267 893.138176 701.759633 817.019477 767.734955 777.248 802.205449 742.347691 811.03081 718.063616 811.603883L718.063616 811.603883Z"></path>
</svg>

    </a>
  
    <a href="https://www.linkedin.com/in/hsiufukuo" rel="me noopener" class="iconfont"
      title="linkedin"  target="_blank"
      >
      <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="33" height="33">
  <path d="M872.405333 872.618667h-151.637333v-237.610667c0-56.661333-1.152-129.578667-79.018667-129.578667-79.061333 0-91.136 61.653333-91.136 125.397334v241.792H398.976V384h145.664v66.602667h1.962667c20.352-38.4 69.845333-78.933333 143.786666-78.933334 153.642667 0 182.058667 101.12 182.058667 232.746667v268.202667zM227.712 317.141333a87.978667 87.978667 0 0 1-88.021333-88.106666 88.064 88.064 0 1 1 88.021333 88.106666z m76.032 555.477334H151.68V384h152.064v488.618667zM948.266667 0H75.562667C33.792 0 0 33.024 0 73.770667v876.458666C0 991.018667 33.792 1024 75.562667 1024h872.576C989.866667 1024 1024 991.018667 1024 950.229333V73.770667C1024 33.024 989.866667 0 948.138667 0h0.128z"></path>
</svg>

    </a>
  
    <a href="https://github.com/rubinera1n" rel="me noopener" class="iconfont"
      title="github"  target="_blank"
      >
      <svg class="icon" style="" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="36" height="36">
  <path d="M512 12.672c-282.88 0-512 229.248-512 512 0 226.261333 146.688 418.133333 350.08 485.76 25.6 4.821333 34.986667-11.008 34.986667-24.618667 0-12.16-0.426667-44.373333-0.64-87.04-142.421333 30.890667-172.458667-68.693333-172.458667-68.693333C188.672 770.986667 155.008 755.2 155.008 755.2c-46.378667-31.744 3.584-31.104 3.584-31.104 51.413333 3.584 78.421333 52.736 78.421333 52.736 45.653333 78.293333 119.850667 55.68 149.12 42.581333 4.608-33.109333 17.792-55.68 32.426667-68.48-113.706667-12.8-233.216-56.832-233.216-253.013333 0-55.893333 19.84-101.546667 52.693333-137.386667-5.76-12.928-23.04-64.981333 4.48-135.509333 0 0 42.88-13.738667 140.8 52.48 40.96-11.392 84.48-17.024 128-17.28 43.52 0.256 87.04 5.888 128 17.28 97.28-66.218667 140.16-52.48 140.16-52.48 27.52 70.528 10.24 122.581333 5.12 135.509333 32.64 35.84 52.48 81.493333 52.48 137.386667 0 196.693333-119.68 240-233.6 252.586667 17.92 15.36 34.56 46.762667 34.56 94.72 0 68.522667-0.64 123.562667-0.64 140.202666 0 13.44 8.96 29.44 35.2 24.32C877.44 942.592 1024 750.592 1024 524.672c0-282.752-229.248-512-512-512"></path>
</svg>

    </a>


<a href="https://blog.xiufuguo.com/index.xml" rel="noopener alternate" type="application/rss&#43;xml"
    class="iconfont" title="rss" target="_blank">
    <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="30" height="30">
  <path d="M819.157333 1024C819.157333 574.592 449.408 204.8 0 204.8V0c561.706667 0 1024 462.293333 1024 1024h-204.842667zM140.416 743.04a140.8 140.8 0 0 1 140.501333 140.586667A140.928 140.928 0 0 1 140.074667 1024C62.72 1024 0 961.109333 0 883.626667s62.933333-140.544 140.416-140.586667zM678.784 1024h-199.04c0-263.210667-216.533333-479.786667-479.744-479.786667V345.173333c372.352 0 678.784 306.517333 678.784 678.826667z"></path>
</svg>

  </a>
   
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - <a class="theme-link" href="https://github.com/xianmin/hugo-theme-jane">Jane</a>
  </span>

  <span class="copyright-year">
    &copy;
    
      2017 -
    2020
    <span class="heart">
      
      <i class="iconfont">
        <svg class="icon" viewBox="0 0 1025 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="14" height="14">
  <path d="M1000.1 247.9c-15.5-37.3-37.6-70.6-65.7-98.9-54.4-54.8-125.8-85-201-85-85.7 0-166 39-221.4 107.4C456.6 103 376.3 64 290.6 64c-75.1 0-146.5 30.4-201.1 85.6-28.2 28.5-50.4 61.9-65.8 99.3-16 38.8-24 79.9-23.6 122.2 0.7 91.7 40.1 177.2 108.1 234.8 3.1 2.6 6 5.1 8.9 7.8 14.9 13.4 58 52.8 112.6 102.7 93.5 85.5 209.9 191.9 257.5 234.2 7 6.1 15.8 9.5 24.9 9.5 9.2 0 18.1-3.4 24.9-9.5 34.5-30.7 105.8-95.9 181.4-165 74.2-67.8 150.9-138 195.8-178.2 69.5-57.9 109.6-144.4 109.9-237.3 0.1-42.5-8-83.6-24-122.2z"
   fill="#8a8a8a"></path>
</svg>

      </i>
    </span><span class="author">
        rubinera1n
        
      </span></span>

  
  

  
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont">
        
        <svg class="icon" viewBox="0 0 1024 1024" version="1.1"
  xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
  width="35" height="35">
  <path d="M510.866688 227.694839 95.449397 629.218702l235.761562 0-2.057869 328.796468 362.40389 0L691.55698 628.188232l241.942331-3.089361L510.866688 227.694839zM63.840492 63.962777l894.052392 0 0 131.813095L63.840492 195.775872 63.840492 63.962777 63.840492 63.962777zM63.840492 63.962777"></path>
</svg>

      </i>
    </div>
  </div>
  
<script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>




<script type="text/javascript" src="/js/main.638251f4230630f0335d8c6748e53a96f94b72670920b60c09a56fdc8bece214.js" integrity="sha256-Y4JR9CMGMPAzXYxnSOU6lvlLcmcJILYMCaVv3Ivs4hQ=" crossorigin="anonymous"></script>












  
    <script type="text/javascript" src="/js/load-photoswipe.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe.min.js"></script>
    <script type="text/javascript" src="/lib/photoswipe/photoswipe-ui-default.min.js"></script>
  















</body>
</html>
